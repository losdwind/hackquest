# 4 Chainlink集成

> 集成Chainlink价格预言机，包含心跳检查和过时价格保护。

| 时间戳 | 内容 |
| :--- | :--- |
| 00:00:00,000 | 这里 |
| 00:00:00,721 | 虽然可以用external view函数 |
| 00:00:02,820 | function get token amount from USD 然后 |
| 00:00:06,601 | 我们要传入一个address token或者 |
| 00:00:09,480 | collateral |
| 00:00:10,500 | units 256 USD amount in way 这将是 |
| 00:00:15,361 | 一个 |
| 00:00:16,261 | public view returns un256. |
| 00:00:20,820 | 我们要做一些价格预言机 |
| 00:00:23,400 | 相关的东西，所以我们需要什么 |
| 00:00:25,261 | 我们需要做什么呢，我们需要 |
| 00:00:26,161 | 获取eth或者token的价格然后 |
| 00:00:29,820 | 我们需要说好的那么 |
| 00:00:31,381 | 如果定价是 |
| 00:00:33,181 | 美元每eth 并且我们有eth |
| 00:00:36,420 | 我们怎么得到美元呢 |
| 00:00:38,040 | 好吧如果我们在这里做一些数学计算假设 |
| 00:00:40,500 | 是两千美元的eth我们有 |
| 00:00:42,781 | 有 |
| 00:00:43,920 | 一千美元 |
| 00:00:45,540 | 对吧那是多少eth我们要 |
| 00:00:47,761 | 用1000除以2000这 |
| 00:00:50,820 | 等于0.5 eth对吧所以我们 |
| 00:00:53,820 | 要用这个数字除以这个 |
| 00:00:56,460 | 数字，也就是USD amount in way |
| 00:00:58,920 | 除以价格，这样 |
| 00:01:01,861 | 我们就能得到这个token或者 |
| 00:01:03,900 | collateral的数量从usdml所以 |
| 00:01:07,079 | 我们说aggregator V3 interface |
| 00:01:10,320 | price feed等于aggregator V3 |
| 00:01:13,441 | interface of S price feet of token哦 |
| 00:01:16,980 | 哇甚至 |
| 00:01:19,560 | 帮我构建了很多这太 |
| 00:01:20,881 | 棒了是的这看起来是对的所以我们 |
| 00:01:22,681 | 要获取token的价格预言机 |
| 00:01:24,480 | 然后调用latest round data |
| 00:01:26,579 | 来在这里获取价格然后 |
| 00:01:29,281 | 我们就在这里做这个 |
| 00:01:32,521 | 所以我们要说amount USD in |
| 00:01:36,060 | way |
| 00:01:37,021 | 除以价格或者unit 56 price |
| 00:01:41,641 | 这是完整的故事吗？绝对不是 |
| 00:01:43,740 | 因为我们应该总是先乘 |
| 00:01:45,601 | 所以我们要用这个乘以我们的 |
| 00:01:47,601 | Precision然后我们可以除以 |
| 00:01:50,460 | 价格但这是完整的故事吗不 |
| 00:01:52,320 | 因为价格有八位小数 |
| 00:01:54,121 | 位，而我们需要18位所以我们 |
| 00:01:57,480 | 要做additional feed Precision像 |
| 00:02:00,301 | 这样 |
| 00:02:02,161 | 是Alec对吧所以如果我们有比如说我们 |
| 00:02:05,579 | 有10 e 18 |
| 00:02:07,980 | 作为amount in way我们要把它 |
| 00:02:10,079 | 乘以one E18像这样我们说除以 |
| 00:02:14,761 | 价格假设价格是 |
| 00:02:16,681 | 两千美元两千 |
| 00:02:18,121 | 美元e eight |
| 00:02:20,521 | 乘以one E10这个额外的 |
| 00:02:24,841 | 部分这看起来很正确还有什么 |
| 00:02:27,301 | 吗让我们把计算器拿出来 |
| 00:02:28,500 | 对吧所以10一二三 |
| 00:02:31,381 | 四五六七八一二三 |
| 00:02:33,060 | 四五六 |
| 00:02:34,681 | 七八九十乘以一一二 |
| 00:02:38,701 | 三四五六七八一二 |
| 00:02:40,500 | 三四五六七八九十 |
| 00:02:42,420 | 除以二一二三二 |
| 00:02:46,201 | 千一二三四五六 |
| 00:02:48,060 | 七八九十一二三四 |
| 00:02:49,560 | 五六七八等于这个数字 |
| 00:02:52,560 | 大概是一半对吧一二 |
| 00:02:54,781 | 一二三四五六七八 |
| 00:02:57,361 | 九十十一十二十三十四 |
| 00:02:59,941 | 十五好的一二三四 |
| 00:03:02,701 | 五六七八九一二三 |
| 00:03:05,521 | 四五六七 |
| 00:03:07,980 | 八九 |
| 00:03:10,801 | 八九 |
| 00:03:12,480 | 零点这对吗哦因为是 |
| 00:03:15,540 | 十美元对是的这是对的我 |
| 00:03:17,941 | 还以为我们做的是一千美元 |
| 00:03:19,141 | 但这是十美元是的好酷 |
| 00:03:21,480 | 这对我来说看起来很好然后 |
| 00:03:23,460 | 显然我们很快会测试这个 |
| 00:03:24,900 | 确保它是对的所以我们有 |
| 00:03:26,820 | 这个函数我们从USD获取token |
| 00:03:28,861 | 数量所以我们说嘿 |
| 00:03:30,841 | 我们要偿还你100的债务或者 |
| 00:03:33,601 | 类似的东西100 eth值多少 |
| 00:03:35,820 | 你的债务可能是 |
| 00:03:38,101 | 如果价格是两千美元我们 |
| 00:03:40,920 | 显然我们会做 |
| 00:03:42,361 | 100除以两千零点 |
| 00:03:44,641 | 零五就在那里对吧 |
| 00:03:46,320 | 这会是像0.05 eth |
| 00:03:49,801 | 或者不管是多少对吧酷所以我们有 |
| 00:03:52,980 | 我们需要从 |
| 00:03:55,801 | 他们的抵押品中拿走多少eth |
| 00:03:56,941 | 作为偿还这个DSC的奖励但是 |
| 00:04:00,540 | 另外我们还想 |
| 00:04:02,521 | 给他们10%的奖励对吧因为 |
| 00:04:06,241 | 我们想激励他们如果 |
| 00:04:07,741 | 只是一对一他们 |
| 00:04:09,781 | 不会想做这个所以让我们 |
| 00:04:10,920 | 说我们要给他们10%的奖励 |
| 00:04:12,661 | 所以我们给liquidator 110 |
| 00:04:18,560 | 的weth换100 DSC不管110美元 |
| 00:04:23,400 | 的weft是多少我们应该 |
| 00:04:25,621 | 实现一个功能 |
| 00:04:28,141 | 来liquidate以防协议 |
| 00:04:32,960 | 协议资不抵债 |
| 00:04:36,181 | 我们暂时还不会添加 |
| 00:04:37,500 | 虽然但我们可能应该添加 |
| 00:04:39,060 | 类似的东西然后把 |
| 00:04:42,000 | 额外的数量扫入金库但我们 |
| 00:04:46,500 | 不会添加这两个所以 |
| 00:04:47,941 | 如果这令人困惑不要担心 |
| 00:04:49,381 | 不要担心反正我们都不会 |
| 00:04:50,341 | 实现那个所以我们说 |
| 00:04:51,960 | un256 bonus |
| 00:04:53,960 | collateral等于这个token amount |
| 00:04:57,841 | covered |
| 00:04:58,920 | 乘以 |
| 00:05:00,361 | 一些我们还没有定义的liquidation bonus |
| 00:05:03,841 | 虽然我们要做 |
| 00:05:05,101 | 10除以100但我讨厌这些 |
| 00:05:08,579 | 浮点数所以我们要做 |
| 00:05:10,201 | 比100更好的东西我们要做 |
| 00:05:12,301 | Liquidator Precision是100然后 |
| 00:05:15,361 | 我们做U into 256 private constant |
| 00:05:18,560 | liquid Ator bonus等于shun bonus |
| 00:05:25,141 | 是10这意味着 |
| 00:05:28,560 | 10%的奖励 |
| 00:05:30,181 | 因为是10除以100 |
| 00:05:32,341 | 那就是10让我们回到下面 |
| 00:05:34,641 | liquidation bonus除以liquid |
| 00:05:38,460 | ation Precision所以bonus collateral |
| 00:05:42,121 | 是10所以假设 |
| 00:05:45,181 | 是0.5 0.05 eth我们要 |
| 00:05:48,601 | 把它乘以 |
| 00:05:50,521 | 0.1 |
| 00:05:51,900 | 对吧因为我们要先乘 |
| 00:05:53,040 | 然后除以得到 |
| 00:05:55,521 | 0.005 eth所以总共或者那不 |
| 00:05:59,221 | 太对是0.005 |
| 00:06:01,941 | 0.05乘以 |
| 00:06:04,400 | 0.1等于是的所以这意味着他们 |
| 00:06:07,801 | 会得到0.05 |
| 00:06:11,761 | .这对吗我想这是对的为什么 |
| 00:06:15,000 | 为什么我的数学不好 |
| 00:06:17,161 | 我要一是的好酷所以 |
| 00:06:20,761 | 这就是他们要得到的这个 |
| 00:06:21,661 | bonus collateral我们要把bonus |
| 00:06:23,521 | collateral加到 |
| 00:06:24,900 | 实际的抵押品上所以我们 |
| 00:06:27,121 | 说像went to 256 |
| 00:06:28,920 | total collateral collat或all |
| 00:06:32,400 | to redeem等于 |
| 00:06:35,579 | token amount from covered加上bonus |
| 00:06:38,641 | collateral像这样现在我们 |
| 00:06:41,161 | 需要为调用liquidate函数的人赎回这个数量的抵押品 |
| 00:06:43,741 | 对吧我们需要赎回那个 |
| 00:06:45,900 | 抵押品然后我们还需要燃烧 |
| 00:06:47,460 | 这个用户的DSC所以我们 |
| 00:06:49,381 | 需要给他们抵押品并且 |
| 00:06:52,261 | 燃烧他们用来偿还债务的DSC |
| 00:06:54,361 | 他们要偿还的债务 |
| 00:06:56,221 | 来偿还 |
| 00:07:01,021 | 但是现在如果我们看我们的redeemed |
| 00:07:03,060 | collateral in collateral |
| 00:07:06,420 | 函数现在是public对吧我们 |
| 00:07:08,579 | 可以看到作为输入它接受 |
| 00:07:11,221 | 所以collateral address和amount |
| 00:07:12,900 | collateral对吧并且它硬编码为 |
| 00:07:15,480 | message.sender我们的第三方用户 |
| 00:07:18,181 | 不是有坏账的人对吧我们 |
| 00:07:20,641 | 需要赎回一个随机人的 |
| 00:07:22,500 | 抵押品所以我们可以做的是 |
| 00:07:25,079 | 重构这个代码 |
| 00:07:26,941 | 使有一个internal redeemed |
| 00:07:28,801 | collateral函数可以从任何人那里赎回 |
| 00:07:30,900 | 抵押品对吧并且只有 |
| 00:07:33,601 | 非常有权限的函数可以调用 |
| 00:07:36,000 | Redeemed collateral所以我们要 |
| 00:07:38,400 | 做的实际上是我们要拿 |
| 00:07:39,661 | 所有这些代码 |
| 00:07:41,161 | 然后改变它我们要 |
| 00:07:42,781 | 删除它然后把它放到另一个函数里 |
| 00:07:45,960 | 一直到in private internal |
| 00:07:48,661 | 函数这里我们要做一个 |
| 00:07:50,460 | function underscore redeem collateral |
| 00:07:55,381 | 这将是一个internal |
| 00:07:56,701 | 函数我们可以实际从任何人那里赎回 |
| 00:07:58,201 | 抵押品作为输入 |
| 00:08:00,781 | 这将接受address token |
| 00:08:03,480 | collateral address和常规 |
| 00:08:06,060 | redeem collateral一样还有unit 56 |
| 00:08:07,801 | amount collateral但我们要添加 |
| 00:08:10,441 | address from和address to |
| 00:08:14,161 | 所以这样并且这将是 |
| 00:08:15,601 | private所以这样有人可以 |
| 00:08:18,601 | liquidate |
| 00:08:19,801 | 一个address from然后得到奖励 |
| 00:08:21,601 | 到to这就是我要 |
| 00:08:23,701 | 粘贴我们从上面得到的所有代码的地方 |
| 00:08:26,281 | 我认为这看起来不错我们只是 |
| 00:08:29,161 | 要准确粘贴这样的代码 |
| 00:08:30,420 | 不做message.sender |
| 00:08:33,420 | 这只是from然后emit |
| 00:08:36,301 | collateral redeemed我们要 |
| 00:08:38,221 | 更新我们的collateral redeemed |
| 00:08:42,560 | 到redeemed from |
| 00:08:45,841 | 我们做address redeem from address |
| 00:08:48,621 | redeemed to |
| 00:08:51,241 | 我们做token然后我们有 |
| 00:08:53,941 | amount不被indexed所以from to token |
| 00:08:58,261 | 和amount |
| 00:08:59,460 | 所以现在我们要重构其中一些 |
| 00:09:01,079 | 抵押品所以from |
| 00:09:03,361 | 当我们只做常规redeem |
| 00:09:05,040 | collateral时我们一会儿会更新这个 |
| 00:09:06,900 | 实际上是的我们一会儿更新那个 |
| 00:09:08,341 | 所以在这个internal函数里 |
| 00:09:10,441 | 从from |
| 00:09:12,960 | 到address collateral |
| 00:09:16,201 | 然后我们要transfer我们 |
| 00:09:18,420 | 要把token转账到two is所以这将像 |
| 00:09:22,861 | Liquidator amount collateral并做那个 |
| 00:09:25,980 | 现在我们要在我们刚刚创建的常规redeem |
| 00:09:27,661 | lateral函数中使用这个internal |
| 00:09:29,641 | 函数对吧在这上面哦不是 |
| 00:09:34,920 | 这个在这上面我们要 |
| 00:09:37,801 | 删掉所有这些只用这个underscore redeem |
| 00:09:39,781 | collateral对于这里我们只是 |
| 00:09:42,301 | 说message dot sender所以from |
| 00:09:44,641 | message to Sender to Mrs dot sender |
| 00:09:48,661 | token collateral address amount |
| 00:09:50,161 | collateral现在我们有这个 |
| 00:09:51,601 | internal函数我们可以使用这个redeem |
| 00:09:53,641 | collateral bit |
| 00:09:55,021 | 在我们的liquid date下面在 |
| 00:09:57,060 | 这下面我们现在可以只说redeem |
| 00:09:59,941 | collateral |
| 00:10:01,201 | 从正在被liquidated的用户那里所以 |
| 00:10:04,861 | from user到无论谁在调用liquidate |
| 00:10:08,820 | 这里 |
| 00:10:09,781 | 所以是message dot sender |
| 00:10:12,420 | collateral token |
| 00:10:14,460 | 我们正在liquidating |
| 00:10:16,201 | 最后是total collateral to |
| 00:10:18,661 | redeem所以这就是为什么我说我们要 |
| 00:10:20,761 | 很快做一点重构 |
| 00:10:22,079 | 对吧我们通常只想 |
| 00:10:25,381 | 从同一个人那里赎回抵押品 |
| 00:10:26,941 | 然而当我们做 |
| 00:10:29,161 | liquidate时我们要赎回到 |
| 00:10:30,661 | 无论谁在调用liquidate所以 |
| 00:10:32,641 | 他们会得到那个奖励 |
| 00:10:34,441 | total collateral to redeem是那个total |
| 00:10:36,601 | amount debt to cover加上一些bonus |
| 00:10:38,761 | 在这里现在我们实际需要是的我们 |
| 00:10:41,281 | 现在需要燃烧DSC所以现在如果 |
| 00:10:43,381 | 我们看burn DSC我们有这个public |
| 00:10:46,320 | 函数它做同样的事情 |
| 00:10:48,841 | 它只是从 |
| 00:10:50,579 | message.sender燃烧我们要 |
| 00:10:52,621 | 在这里做同样的我们要 |
| 00:10:53,881 | 做一个internal burn DSC函数 |
| 00:10:56,341 | 允许我们从任何人那里燃烧对吧所以 |
| 00:10:59,281 | 如果我们滚动到我们做 |
| 00:11:01,040 | 那些private函数的地方或者向上滚动所以 |
| 00:11:05,101 | 我们有这个internal redeem collateral |
| 00:11:07,201 | 我们还需要一个internal |
| 00:11:09,361 | burn DSC这是一个function我只是 |
| 00:11:11,941 | burn DSC unit 256 amount DSC to burn |
| 00:11:17,781 | address on behalf of像谁的DSC |
| 00:11:24,000 | 我们在为谁燃烧谁的债务我们在偿还 |
| 00:11:26,101 | 然后address DSC from我们从哪里 |
| 00:11:29,820 | 获取DSC我们有private |
| 00:11:32,161 | 我们可以回到burn DSC让我们 |
| 00:11:35,460 | burn DSC函数对吧同样的事情 |
| 00:11:38,341 | 我们可以复制所有这些回到我们的 |
| 00:11:40,980 | internal burn DSC函数粘贴 |
| 00:11:43,261 | 这个在这里我们要 |
| 00:11:45,121 | 更新这个对吧不是 |
| 00:11:46,320 | message.sender |
| 00:11:47,820 | 这将是on behalf of我们 |
| 00:11:51,601 | 要burn我们要拿走 |
| 00:11:53,941 | 他们的债务我们仍然要做这个 |
| 00:11:56,281 | 但不是message.sender而是 |
| 00:11:58,560 | DSC from并且是 |
| 00:12:01,500 | amount DSC to burn |
| 00:12:03,781 | 这仍然很好这只需要是 |
| 00:12:05,941 | amount DSC to burn我们不需要 |
| 00:12:08,221 | 检查 |
| 00:12:09,060 | Health Factor因为这将是 |
| 00:12:10,741 | 我们的internal函数所以我们可能 |
| 00:12:12,361 | 甚至在这里的注释中说 |
| 00:12:15,500 | low level internal function |
| 00:12:18,781 | at Dev low-level internal function |
| 00:12:21,480 | do not call unless |
| 00:12:24,241 | the function calling it |
| 00:12:27,301 | is |
| 00:12:28,621 | checking for health factors being broken |
| 00:12:33,480 | 所以现在我们有这个burn DSC我们可以 |
| 00:12:35,521 | 回到我们的burn DSC函数我们可以 |
| 00:12:38,579 | 只是交换删除所有这些 |
| 00:12:40,861 | 调用burn DSC这可以是message |
| 00:12:43,500 | dot sender message dot sender amount |
| 00:12:46,801 | 对吧如果有人调用burn DSC |
| 00:12:48,661 | 他们自己好我们只是让他们 |
| 00:12:50,460 | 调用这个burn DSC amount to burn on |
| 00:12:53,040 | behalf of他们自己from他们自己 |
| 00:12:54,721 | 看起来我把这些弄反了amount |
| 00:12:56,579 | 应该是第一个 |
| 00:12:57,960 | 好的现在我们有这个burn DSC |
| 00:13:00,480 | 函数我们可以到liquidate并且 |
| 00:13:02,341 | 我们可以调用burn DSC |
| 00:13:04,079 | 什么是呃 |
| 00:13:06,060 | amount on behalf of from所以amount |
| 00:13:10,320 | 是这个debt to cover amount |
| 00:13:13,341 | on behalf of是user并且 |
| 00:13:17,341 | 要付钱的人是 |
| 00:13:18,781 | message.sender对吧因为 |
| 00:13:21,181 | 是无论谁是Liquidator |
| 00:13:22,920 | 无论谁在调用liquidate将 |
| 00:13:24,601 | 是偿还debt to的人 |
| 00:13:27,181 | cover对吧偿还那个minted DSC |
| 00:13:29,341 | 现在因为我们在做这些internal |
| 00:13:31,381 | 调用没有检查我们 |
| 00:13:32,941 | 绝对需要确保我们在 |
| 00:13:34,381 | 检查这个health factor是好的 |
| 00:13:36,540 | 对吧所以我们要做U into two |
| 00:13:38,221 | for six ending user Health Factor等于 |
| 00:13:42,000 | underscore health |
| 00:13:43,380 | factor of the user如果ending |
| 00:13:47,221 | Health factor小于或等于 |
| 00:13:50,341 | starting Health Factor对吧如果我们 |
| 00:13:52,560 | 没有改善health Factor我们 |
| 00:13:54,361 | 应该revert DSC engine |
| 00:13:57,301 | underscore Health factor not improved |
| 00:14:02,060 | 复制这个到顶部我们做error |
| 00:14:06,841 | DSC engine Health Factor not approved回到 |
| 00:14:08,820 | 下面 |
| 00:14:09,900 | 所以如果我们不改善health Factor |
| 00:14:12,540 | 我们应该100%revert然后还有 |
| 00:14:16,681 | 如果调用这个liquidate函数 |
| 00:14:19,261 | 偿还一些债务并做所有这些 |
| 00:14:20,941 | 事情实际上伤害了Liquidators的 |
| 00:14:23,641 | Health Factor我们也应该revert |
| 00:14:25,380 | 对吧所以我们也应该调用revert如果 |
| 00:14:27,540 | Health factor is broken for |
| 00:14:29,460 | the message sender对吧如果这个 |
| 00:14:31,261 | 过程毁了他们的health Factor我们 |
| 00:14:33,301 | 不应该让他们做这个好所以我们 |
| 00:14:36,361 | 遵循checks effects interactions |
| 00:14:37,980 | 在这里 |
| 00:14:38,761 | 大部分 |
| 00:14:40,641 | 这两个 |
| 00:14:42,841 | 函数正在对外部合约进行外部调用 |
| 00:14:45,060 | 对吧然后我们 |
| 00:14:47,161 | 在之后做一种检查 |
| 00:14:48,900 | 再次这是一个权衡我们 |
| 00:14:50,701 | 可以在之前计算然后运行这个 |
| 00:14:52,980 | 但那有点gas效率低我们 |
| 00:14:56,761 | 只是要在我们做完所有这些之后检查 |
| 00:14:58,500 | 嘿只要确保health |
| 00:15:00,241 | factor是好的确保我们没有 |
| 00:15:03,301 | 破坏任何人的Health Factor所以现在我们 |
| 00:15:05,701 | 有这个liquidation函数它是 |
| 00:15:07,441 | 非常强大的并且有点 |
| 00:15:09,301 | 把这整个事情联系在一起对吧 |
| 00:15:10,920 | 这里有一个激励让人们 |
| 00:15:13,261 | 调用liquidate所以我们的协议 |
| 00:15:16,560 | 永远不会资不抵债对吧我知道我一直 |
| 00:15:18,121 | 在抛出很多 |
| 00:15:19,201 | 这些金融术语但我们的协议 |
| 00:15:21,420 | 总是有比它 |
| 00:15:24,900 | minted DSC更多的抵押品抵押品的价值 |
| 00:15:27,181 | 应该总是超过minted |
| 00:15:29,880 | DSC总是非常强大的函数 |
| 00:15:32,521 | 我们显然要测试 |
| 00:15:34,021 | 这个的方方面面对吧因为我们 |
| 00:15:35,521 | 想确保它真的有效哦 |
| 00:15:38,761 | 我们现在需要什么好吧看起来 |
| 00:15:41,161 | 我们弄坏了一些东西哦这需要一个 |
| 00:15:43,621 | 分号我们还弄坏了什么 |
| 00:15:45,661 | 下面有一个小红东西让我们去 |
| 00:15:47,221 | 修复它amount这应该是amount do |
| 00:15:49,920 | you see to burn还有几个 |
| 00:15:52,201 | 红的 |
| 00:15:53,221 | redeem collateral user message sender |
| 00:15:55,741 | redeem collateral呃哦我们把这些 |
| 00:15:58,980 | 弄反了我要复制这些把 |
| 00:16:02,101 | 这些放在前面 |
| 00:16:03,721 | 好哦看起来这修复了大部分 |
| 00:16:06,480 | 这个我在这里侧边看不到更多 |
| 00:16:08,281 | 红色的东西所以我们 |
| 00:16:10,681 | 要继续运行Forge build |
| 00:16:12,480 | 确保至少一切都在 |
| 00:16:13,801 | 编译 |
| 00:16:16,741 | 太棒了也许我们甚至会运行Forge test |
| 00:16:18,661 | 我不认为这会破坏任何 |
| 00:16:20,221 | 测试看起来那些工作正常 |
| 00:16:22,500 | 但好吧我们正在做一些出色的 |
| 00:16:24,361 | 工作就像我说的 |
| 00:16:29,281 | 在这一点上我可能会 |
| 00:16:31,079 | 用这个运行测试但我们几乎 |
| 00:16:32,880 | 完成了这里所有的代码所以我们 |
| 00:16:34,861 | 只是要继续对吧并且这个 |
| 00:16:36,480 | 代码开始看起来相当不错了 |
| 00:16:37,681 | 对吧我们在这里有这些惊人的Nat spec |
| 00:16:40,320 | 注释我们到处都有注释 |
| 00:16:41,941 | 也许这些可能 |
| 00:16:43,681 | 应该稍微清理一下但 |
| 00:16:44,941 | 没关系 |
| 00:16:46,079 | 我们有一点这个小Dev thing |
| 00:16:48,060 | 一个提醒说嘿不要让任何人 |
| 00:16:49,980 | 在不检查的情况下调用burn DSC |
| 00:16:52,500 | health Factor对吧这真的很好 |
| 00:16:54,241 | 告诉Auditors和Security |
| 00:16:55,681 | Professionals关于这个对吧 |
| 00:16:57,540 | 真的很好指出这个我们现在 |
| 00:16:59,579 | 有这个internal redeemed collateral |
| 00:17:01,079 | 函数所以它可以用于 |
| 00:17:02,221 | liquidate或redeemed collateral |
| 00:17:03,721 | Health Factor看起来几乎 |
| 00:17:06,181 | 我们最初写的所有函数 |
| 00:17:08,221 | 都在这里工作对吧并且 |
| 00:17:11,579 | 这一切都有效的原因再次是 |
| 00:17:13,560 | 因为 |
| 00:17:14,460 | 我们mint DSC我们只能mint |
| 00:17:18,241 | 系统中有的抵押品我们 |
| 00:17:20,281 | 本质上在为我们的协议设置这个汇率 |
| 00:17:22,261 | 嘿酷你有100 |
| 00:17:24,781 | 你存入了150美元的eth |
| 00:17:27,661 | 好你可以mint 100美元的DSC |
| 00:17:31,741 | 所以是这个我们 |
| 00:17:33,361 | 设置的汇率在维持价格 |
| 00:17:35,641 | 让我们只是仔细检查我们有 |
| 00:17:37,201 | 我们想要的大部分函数 |
| 00:17:38,460 | 在这里并且让我们也检查 |
| 00:17:40,500 | 它们在正确的位置 |
| 00:17:42,000 | 所以我们到这里的顶部 |
| 00:17:44,221 | 有一大堆Errors那很好 |
| 00:17:46,621 | 有一大堆constants因为 |
| 00:17:48,000 | 我们讨厌魔法数字我们有一个 |
| 00:17:50,400 | price feeds的映射从用户到token到 |
| 00:17:52,801 | 他们存入的数量的collateral |
| 00:17:54,900 | deposited映射我们有他们的 |
| 00:17:57,181 | 债务或他们的DSC minted collateral |
| 00:18:00,060 | Tokens The idsc Token我们有一些 |
| 00:18:03,181 | events在这里 |
| 00:18:04,861 | 几个modifiers一些functions |
| 00:18:08,400 | 我们有一种方法在一个交易中deposit抵押品 |
| 00:18:10,861 | 和mint DSC我们 |
| 00:18:14,221 | 有一种方法计算health Factor我 |
| 00:18:15,960 | 现在要告诉你 |
| 00:18:17,221 | 这里实际上有一个bug哦我 |
| 00:18:19,920 | 不会告诉你那个bug是什么 |
| 00:18:21,000 | 虽然 |
| 00:18:22,321 | 也许你能找出来我们有 |
| 00:18:24,361 | 一些view函数在下面我们 |
| 00:18:26,161 | 可能要在我们写的时候添加更多 |
| 00:18:27,601 | 测试 |
| 00:18:28,621 | 但这看起来相当不错现在 |
| 00:18:32,521 | 就像我说的这里至少有一个大bug |
| 00:18:34,560 | 甚至可能有并且 |
| 00:18:36,000 | 可能还有更多但至少有一个大 |
| 00:18:37,621 | bug在这里 |
| 00:18:38,761 | 所以现在是休息的好时机 |
| 00:18:40,801 | 因为在这之后我们要 |
| 00:18:43,500 | 深入编写测试或这个 |
| 00:18:46,621 | 协议我们要写一些新的 |
| 00:18:48,480 | 测试我们要向你展示一些 |
| 00:18:49,920 | 真正高级的测试方法 |
| 00:18:52,621 | 所以休息一下去散步 |
| 00:18:55,500 | 一会儿见 |
| 00:19:11,101 | 好的那么让我们打开我们的终端 |
| 00:19:12,480 | 这里Forge |
| 00:19:15,601 | coverage |
| 00:19:24,181 | 哦我们有一些工作要做 |
| 00:19:26,400 | 好吧好现在没有比现在更好的时机 |
| 00:19:28,681 | 让我们开始吧所以我们有一些price |
| 00:19:31,441 | feed测试在这里我们可能也 |
| 00:19:34,021 | 想设置一些构造测试 |
| 00:19:35,701 | 对吧我们想确保东西被 |
| 00:19:37,441 | 正确初始化所以让我们 |
| 00:19:39,361 | 复制那个我们做constructor |
| 00:19:41,761 | structure structure tests像那样 |
| 00:19:45,601 | 我们会修复这个不然ADHD会发疯 |
| 00:19:48,781 | 我们做 |
| 00:19:50,161 | function |
| 00:19:51,601 | test |
| 00:19:52,920 | something我们在测试什么让我们去 |
| 00:19:55,861 | 到这里的constructor我们 |
| 00:19:58,261 | 应该测试什么好吧我们在做 |
| 00:19:59,761 | 这个revert在这里所以我们应该确保 |
| 00:20:01,801 | 我们实际上在正确revert |
| 00:20:03,661 | 当长度不一样时所以 |
| 00:20:06,121 | function test reverts if token length |
| 00:20:10,441 | doesn't match price feeds |
| 00:20:16,201 | public放大放大我们要 |
| 00:20:20,161 | 在这里待一会儿所以function像这样 |
| 00:20:23,161 | 我们要做我们要 |
| 00:20:25,681 | 创建一些address数组address array |
| 00:20:29,460 | public token addresses |
| 00:20:32,101 | address array |
| 00:20:34,580 | public price |
| 00:20:37,920 | feed |
| 00:20:39,181 | addresses |
| 00:20:41,221 | 我们说token addresses dot push |
| 00:20:43,861 | 我们要push weft到这里 |
| 00:20:46,080 | feed |
| 00:20:47,181 | addresses add dot push FUSD |
| 00:20:52,380 | price feed我们要push 2到 |
| 00:20:54,361 | 这里哦酷BTC我们有吗我猜我们 |
| 00:20:58,500 | 应该pull BTC USD price feed让我们也得到 |
| 00:21:02,701 | 这个所以 |
| 00:21:04,441 | FUSD BTC USD price feed好的 |
| 00:21:08,761 | 哦price feed addresses price feed |
| 00:21:10,920 | addresses所以我们要push那两个 |
| 00:21:12,361 | 进去现在我们做vm dot expect |
| 00:21:17,060 | revert DSC engine |
| 00:21:20,641 | dot什么是error的名字让我 |
| 00:21:23,221 | 复制这个 |
| 00:21:24,960 | boom dot select selector像那样 |
| 00:21:28,621 | 做一些toggle word wrap现在expect |
| 00:21:31,021 | reverts现在我们调用 |
| 00:21:33,781 | 一个new DSC engine |
| 00:21:36,540 | 用token addresses和price |
| 00:21:39,121 | feed addresses哦还有什么进入DSC |
| 00:21:41,761 | 哦我们还需要address DSC |
| 00:21:44,761 | 对吧address DSC所以这应该revert |
| 00:21:48,060 | 让我们看forge test dash m |
| 00:21:54,900 | 好nice好那通过了好 |
| 00:21:56,941 | 酷price feed测试我们在测试 |
| 00:21:59,221 | 获取USD值 |
| 00:22:01,980 | 我认为我们下面还有另一个 |
| 00:22:03,960 | 对吧我们有类似get |
| 00:22:06,540 | token amount from USD我们确实有这个 |
| 00:22:09,841 | 是个public view所以让我们测试这个 |
| 00:22:12,060 | 也 |
| 00:22:13,201 | 做function tests我通常只是 |
| 00:22:16,261 | 喜欢粘贴函数名 |
| 00:22:17,521 | 尤其当它们像这样时 |
| 00:22:19,801 | public |
| 00:22:22,141 | 所以我们要做基本上 |
| 00:22:23,641 | 与此相反这得到了一些ether amount的USD值 |
| 00:22:25,980 | 我们要做 |
| 00:22:27,900 | uint256 |
| 00:22:30,781 | USD amount对吧等于假设100 |
| 00:22:34,681 | eighth 100 ether然后unit 256 |
| 00:22:38,781 | expected |
| 00:22:40,380 | weth做一点数学这里如果我们 |
| 00:22:42,960 | 有如果是每eth两千美元 |
| 00:22:46,261 | 我们有 |
| 00:22:48,480 | 100我们要做一百除以 |
| 00:22:51,241 | 两千所以100除以2000 |
| 00:22:54,380 | 0.05所以我们可以说expected weth是0.05 |
| 00:22:57,900 | ether现在我们做uint two for six |
| 00:23:00,540 | actual weth等于dsce dot这个 |
| 00:23:05,580 | 函数用小写传入weth |
| 00:23:08,221 | 然后USD amount assert equal |
| 00:23:13,341 | expected |
| 00:23:16,261 | expected weth和actual weth |
| 00:23:18,721 | 这两个应该一样让我们 |
| 00:23:20,341 | 测试一下Forge test dash m |
| 00:23:26,880 | nice那通过了好让我们继续 |
| 00:23:29,040 | deposit collateral测试test revert |
| 00:23:32,400 | of collateral zero那很好 |
| 00:23:34,681 | 还有什么让我们到这个deposit |
| 00:23:36,601 | collateral deposit collateral |
| 00:23:40,560 | function |
| 00:23:41,821 | 好我们也应该在这里revert我们 |
| 00:23:44,161 | 基本上只是要通过这个 |
| 00:23:45,540 | 整个函数并且有点测试每一 |
| 00:23:47,460 | 行我们刚测试了这个让我们测试 |
| 00:23:49,560 | 这个所以这将像 |
| 00:23:51,601 | function |
| 00:23:53,221 | test reverts with unapproved |
| 00:23:57,301 | collateral |
| 00:24:00,021 | public我们做一个erc20 mock一些 |
| 00:24:04,021 | rand token对吧我们只做一些 |
| 00:24:06,241 | 随机token new erc20 mock ran将是 |
| 00:24:10,980 | 名字ran |
| 00:24:12,841 | 将是token我们这里有个user |
| 00:24:16,380 | 我想我们有个user对吧好的 |
| 00:24:17,821 | 是的我们有个user |
| 00:24:19,681 | 让我们给这个用户钱然后 |
| 00:24:23,101 | 我们给他们一些starting amount |
| 00:24:25,201 | 我想我们有 |
| 00:24:26,580 | starting erc20 balance或amount |
| 00:24:29,701 | collateral是的我们做amount |
| 00:24:30,900 | collateral给他们amount |
| 00:24:32,580 | collateral我们做vm dot |
| 00:24:35,400 | start prank这个有这个token的user |
| 00:24:38,960 | 他们要尝试deposit这个 |
| 00:24:41,641 | collateral我们要期待它 |
| 00:24:43,321 | revert所以vm dot expect |
| 00:24:46,400 | revert这个error在这里是allowed |
| 00:24:51,480 | token对吧现在不 |
| 00:24:54,060 | 接受任何参数 |
| 00:24:56,161 | 所以那对我们来说足够容易让我们只是 |
| 00:24:58,741 | 复制这个我们做 |
| 00:25:00,861 | DSC engine |
| 00:25:02,841 | dot this dot selector |
| 00:25:06,000 | 然后我们做我们调用deposit |
| 00:25:08,641 | collateral所以dsce dot deposit |
| 00:25:11,821 | collateral address of那个rand token |
| 00:25:14,761 | 对吧brand token或random token我们做 |
| 00:25:17,161 | amount collateral也所以只是 |
| 00:25:19,021 | 那整个amount |
| 00:25:20,880 | 然后我们可以做vm.stop prank那 |
| 00:25:23,880 | 应该 |
| 00:25:24,781 | 工作Forge test dash m |
| 00:25:29,161 | 看看那是否正确 |
| 00:25:32,400 | 是的看起来不错好让我们继续 |
| 00:25:34,141 | 还有什么接下来是什么deposit |
| 00:25:36,960 | collateral不是那个好做了这个 |
| 00:25:38,941 | 做了这个non-reentrant我们可以继续 |
| 00:25:41,821 | 测试reentrant我 |
| 00:25:43,321 | 现在暂时跳过做那个但我们可能 |
| 00:25:44,941 | 确实想在某个时候做一些重入测试 |
| 00:25:46,861 | 在某个时候 |
| 00:25:47,941 | 但是的我现在要跳过它们 |
| 00:25:49,560 | 好酷所以然后我们可以开始 |
| 00:25:52,021 | 测试其中一些所以如果他们deposit |
| 00:25:54,781 | collateral我们应该看到他们 |
| 00:25:57,241 | 实际做这个我们应该看到他们 |
| 00:25:59,341 | emit一个event让我们继续做那个 |
| 00:26:01,861 | 所以让我们做function |
| 00:26:04,261 | test |
| 00:26:05,400 | can |
| 00:26:06,900 | deposit collateral |
| 00:26:09,741 | 并且get account info因为 |
| 00:26:15,060 | 一旦他们deposit我们有这个get |
| 00:26:17,880 | accounts info |
| 00:26:19,920 | 哦现在是private |
| 00:26:22,021 | 所以让我们实际到底部让我们 |
| 00:26:23,521 | 创建一个那个的public版本所以我们 |
| 00:26:25,681 | 做function get account information |
| 00:26:31,801 | 这将是external |
| 00:26:34,080 | external view |
| 00:26:36,060 | returns |
| 00:26:37,500 | 我会return这个account address user |
| 00:26:41,641 | returns这两个我要复制这个 |
| 00:26:43,380 | 回去 |
| 00:26:45,480 | 呃external view returns |
| 00:26:50,641 | 这两个东西 |
| 00:26:52,021 | 我们要说 |
| 00:26:53,941 | total DSC minted comma |
| 00:26:56,460 | collateral value in USD等于这个 |
| 00:26:59,040 | internal函数那应该 |
| 00:27:01,621 | 好对吧哦我们要做不是 |
| 00:27:04,441 | message.sender我们做address |
| 00:27:06,661 | user这个把user粘贴在这里所以现在 |
| 00:27:10,621 | 我们可以从一个external view函数获取total DSC minted和 |
| 00:27:12,241 | 他们的collateral value in USD |
| 00:27:14,101 | 我们应该能够得到那个 |
| 00:27:15,781 | 信息 |
| 00:27:16,980 | 信息 |
| 00:27:17,941 | 所以 |
| 00:27:19,080 | 让我们让他们实际deposit |
| 00:27:20,761 | collateral在这里 |
| 00:27:22,261 | 因为我们要做很多 |
| 00:27:23,821 | deposited collaterals我们知道我们可以 |
| 00:27:25,621 | 实际做一个modifier叫 |
| 00:27:28,161 | deposited collateral |
| 00:27:31,681 | 这个 |
| 00:27:32,761 | vm start prank |
| 00:27:35,641 | user |
| 00:27:37,621 | 你会看到erc20 mock |
| 00:27:40,021 | weth为了deposit weth我们需要 |
| 00:27:42,241 | approve |
| 00:27:43,201 | address dsce comma amount collateral |
| 00:27:49,380 | 我们要做 |
| 00:27:51,080 | dsce.deposit collateral weth amount |
| 00:27:53,761 | collateral |
| 00:27:54,781 | vm dot stop prank vm dot stop prank |
| 00:27:58,560 | 我只是这样做modifier |
| 00:28:02,341 | 对吧我们让这个can deposit |
| 00:28:05,281 | collateral and get account info我们让 |
| 00:28:06,781 | 他们deposit collateral我们 |
| 00:28:09,181 | 现在得到那个account信息所以 |
| 00:28:11,221 | 我们说uint256 |
| 00:28:13,801 | total DSC minted uint256 collateral |
| 00:28:19,580 | value in USD等于dsce dot |
| 00:28:25,080 | get account information in the user哦 |
| 00:28:30,241 | from the user现在我们要说 |
| 00:28:33,540 | 我们要确保这两个 |
| 00:28:35,580 | 数字是正确的total DSC minted |
| 00:28:38,040 | 和collateral value in USD他们 |
| 00:28:40,321 | 应该没有minted DSC所以uint256 |
| 00:28:43,080 | expected expected |
| 00:28:46,021 | total DSC minted是等于零uint256 |
| 00:28:50,941 | expected |
| 00:28:53,181 | collateral value in USD等于这 |
| 00:28:57,540 | 将是那个dsce dot get token |
| 00:29:01,441 | amount from USD weth collateral value in |
| 00:29:07,201 | USD |
| 00:29:08,701 | 所以expected collateral value应该只是 |
| 00:29:11,040 | 这个函数然后我们可以说assert |
| 00:29:13,500 | equal |
| 00:29:15,480 | DSC minted应该是这个expected total |
| 00:29:18,721 | DSC minted然后我们可以做assert |
| 00:29:20,641 | equal |
| 00:29:21,960 | collateral value in USD将是 |
| 00:29:24,181 | 这个expected collateral value in USD |
| 00:29:26,460 | 好clear Orange |
| 00:29:29,761 | test dash m |
| 00:29:35,460 | 或者我们有个fail你知道该做什么 |
| 00:29:37,021 | 我们要再运行一次dash vvv看 |
| 00:29:40,021 | 我们在这里搞砸了什么 |
| 00:29:45,900 | 说assertion失败了 |
| 00:29:48,181 | 左边是这个数字右边是一个小得多 |
| 00:29:51,960 | 的数字这就是为什么做两种类型的asserts不酷 |
| 00:29:54,121 | 但我知道 |
| 00:29:56,101 | 是第二个所以我们说 |
| 00:29:57,420 | collateral value in USD是这个用 |
| 00:29:59,880 | 右边 |
| 00:30:01,321 | 是expected collateral value将 |
| 00:30:03,721 | 是这个所以让我们看看这里有什么问题 |
| 00:30:05,580 | 一二三四五六七八 |
| 00:30:07,621 | 九十一二三四五六 |
| 00:30:09,480 | 七八所以它说 |
| 00:30:12,721 | collateral value in USD是20 grand |
| 00:30:15,301 | 那有道理吗 |
| 00:30:16,500 | 好吧是10 ether |
| 00:30:18,900 | 乘以两千美元 |
| 00:30:21,441 | 等于20 grand对吧所以那 |
| 00:30:27,781 | collateral value USD是对的看起来 |
| 00:30:29,701 | 我的right是错的collateral |
| 00:30:32,821 | expected collateral value USD do |
| 00:30:35,161 | you see that from token amount with哦 |
| 00:30:37,861 | 我到底为什么这样做一 |
| 00:30:39,960 | 二三四五六七八九 |
| 00:30:41,400 | 十一二三四五六七 |
| 00:30:43,321 | 八所以它说二十 |
| 00:30:47,580 | 千美元等于十eth所以 |
| 00:30:50,761 | 我不知道我为什么调用这个 |
| 00:30:52,500 | 哦这实际上是expected |
| 00:30:55,141 | expected deposit amount我们不应该 |
| 00:30:59,281 | 比较这两个 |
| 00:31:01,080 | 这应该和amount比较 |
| 00:31:03,841 | collateral对吧所以10是我们 |
| 00:31:06,420 | 在这里放入的collateral数量 |
| 00:31:08,101 | 然后 |
| 00:31:09,661 | collateral value in USD是的那是对的 |
| 00:31:12,601 | 所以我们得到我们用这个 |
| 00:31:14,040 | collateral value in USD来得到 |
| 00:31:15,480 | expected deposit amount那看起来更 |
| 00:31:18,301 | 正确好酷Forge test dash m |
| 00:31:23,040 | 这是写测试的一种奇怪 |
| 00:31:25,080 | 部分对吧好 |
| 00:31:27,000 | 酷我们修复了它有时你的测试是 |
| 00:31:29,341 | 错的 |
| 00:31:30,121 | 就像我们刚刚展示的这里我写我的 |
| 00:31:31,801 | 测试错了但有时你的代码是 |
| 00:31:34,500 | 错的那就是这些测试真的 |
| 00:31:36,420 | 应该测试的嘿什么时候代码 |
| 00:31:38,101 | 实际上是错的我们在做一些 |
| 00:31:39,781 | 进展Forge coverage |
| 00:31:48,000 | 这里没有很多很好的覆盖率 |
| 00:31:49,321 | 让我们继续所以不是我只是 |
| 00:31:52,380 | 带你走过其余的 |
| 00:31:54,661 | 这些测试你知道怎么写这些 |
| 00:31:57,420 | 测试在这个文件里我真的不会 |
| 00:31:59,941 | 在这里向你展示任何更多独特的测试对吧 |
| 00:32:02,761 | 但就像我说的我们的DSC至少有一个 |
| 00:32:04,980 | 明显的问题 |
| 00:32:08,480 | engine.sol这里有一个大问题 |
| 00:32:10,560 | 对吧我们肯定还需要一些getter |
| 00:32:12,060 | 函数所以写getter |
| 00:32:13,920 | 函数当你测试但至少有 |
| 00:32:15,960 | 一个巨大的问题所以我现在 |
| 00:32:18,420 | 要做的不是我真的 |
| 00:32:20,521 | 带你走过其余的这些 |
| 00:32:22,261 | 测试我是说你可以看到所有的 |
| 00:32:24,960 | 测试在这里因为我要 |
| 00:32:26,281 | 挑战你自己写这些测试 |
| 00:32:28,141 | 自己 |
| 00:32:28,980 | 来提高这个Forge coverage记住 |
| 00:32:32,341 | 你可以做Forge coverage来显然 |
| 00:32:35,101 | 看看发生了什么我们专注于 |
| 00:32:37,560 | 这个现在你也可以做Forge |
| 00:32:40,500 | coverage dash dash report to see dash |
| 00:32:44,221 | dash report debug |
| 00:32:46,321 | 来实际看到缺少的确切行 |
| 00:32:48,841 | 对吧所有这些东西只是 |
| 00:32:50,880 | 某种行项目行项目 |
| 00:32:52,920 | 不管我看不重要滚动 |
| 00:32:55,021 | 滚动滚动滚动好这些是 |
| 00:32:57,060 | 实际上有问题的对吧什么 |
| 00:32:59,941 | 这是哪个哦那是essential |
| 00:33:01,980 | 那是decentralized stable coin我们 |
| 00:33:03,721 | 也想为那个写测试但 |
| 00:33:05,580 | 让我们只关注这个巨大的列表 |
| 00:33:08,400 | 这里DSC engine关注这个列表并且 |
| 00:33:11,281 | 为这个写一些测试因为是的 |
| 00:33:13,261 | 这些单元测试或staging的其余部分 |
| 00:33:15,721 | 测试我们不会学到任何 |
| 00:33:17,701 | 新东西这只是这些事情之一 |
| 00:33:19,621 | 你必须做你必须变得 |
| 00:33:21,721 | 擅长你必须写现在你 |
| 00:33:23,460 | 不必达到100如果你得到 |
| 00:33:25,741 | 到像85 90那很好一些 |
| 00:33:29,161 | 这些测试实际上非常 |
| 00:33:30,661 | 难写但你应该 |
| 00:33:33,601 | 写这些测试应该找到一个 |
| 00:33:35,641 | 明显的bug在这些至少一个 |
| 00:33:38,821 | 函数中也许如果你找到更多 |
| 00:33:41,040 | 超过一个明显的bug那很好做一个 |
| 00:33:43,441 | PR做一个issue到repo但我想 |
| 00:33:46,141 | 你暂停视频花一些 |
| 00:33:48,781 | 时间对吧可能是一个小时可能 |
| 00:33:50,521 | 是两个小时可能是30分钟 |
| 00:33:51,781 | 对吧这取决于你的AI |
| 00:33:53,400 | 伙伴有多快你有多快并写 |
| 00:33:55,980 | 一些更多的测试有时实际上 |
| 00:33:58,321 | 你甚至可以来到你的合约并且 |
| 00:34:00,960 | 你可以做像抓住这个 |
| 00:34:02,761 | 去你的ChatGPT说嘿 |
| 00:34:05,661 | 这是我的solidity函数之一可以 |
| 00:34:10,021 | 你为它写一些测试或it in |
| 00:34:14,400 | Foundry因为它不知道什么 |
| 00:34:17,221 | Foundry是它会完全 |
| 00:34:19,021 | 搞砸但你可以用ChatGPT |
| 00:34:21,601 | 来帮你写一些测试也 |
| 00:34:22,741 | 帮你提高你的覆盖率但 |
| 00:34:24,601 | 这里肯定有一个主要问题 |
| 00:34:26,641 | 你甚至可能需要回去并且 |
| 00:34:28,560 | 重构一些代码对吧我要 |
| 00:34:30,900 | 说尽量少做那个虽然但 |
| 00:34:32,580 | 有一些地方也许你 |
| 00:34:34,321 | 需要重构你的代码来使 |
| 00:34:36,480 | 写测试更容易也许你需要 |
| 00:34:38,341 | 写一些更多的helper函数对吧 |
| 00:34:39,540 | 花这个时间来实验和修补 |
| 00:34:42,241 | 并思考我应该做什么我怎么能 |
| 00:34:45,420 | 确保我的代码是安全的并且 |
| 00:34:48,121 | 重要的是我怎么能写足够的测试 |
| 00:34:50,641 | 来找到Patrick正在谈论的这个bug |
| 00:34:52,380 | 对吧 |
| 00:34:53,701 | 所以也许你现在做一些重构 |
| 00:34:55,861 | 不要写任何fuzz测试我们 |
| 00:34:57,661 | 要稍后讨论fuzz测试 |
| 00:34:58,981 | 但是的只是尝试写其余的 |
| 00:35:00,661 | 这些单元测试其余这些伪 |
| 00:35:02,460 | 集成测试我会看到你当 |
| 00:35:04,500 | 你从另一边出来但当你 |
| 00:35:06,060 | 完成写测试休息一下 |
| 00:35:08,761 | 花点时间我想让这个沉淀下来 |
| 00:35:11,761 | 这是一个这是你要在这个 |
| 00:35:14,540 | 课程中上的最高级的课 |
| 00:35:17,221 | 并且老实说可能 |
| 00:35:19,621 | 将是你在solidity中会上的最高级的课之一 |
| 00:35:22,201 | 好所以我想让你花你的时间 |
| 00:35:24,361 | 在这上面我想让你理解 |
| 00:35:25,920 | 发生了什么有时甚至可能 |
| 00:35:28,321 | 对你有意义去哦好maker DAO做什么 |
| 00:35:29,821 | 我怎么能学到更多 |
| 00:35:32,101 | 关于stablecoins我还能去哪里 |
| 00:35:34,201 | 也许我可以向ChatGPT问问题 |
| 00:35:36,901 | 对吧你们那些说啊我 |
| 00:35:39,661 | 真的不想做那个你可以100% |
| 00:35:41,341 | 只是复制粘贴我的但我建议你 |
| 00:35:44,701 | 经历这个练习 |
| 00:35:47,460 | 好的 |
| 00:35:48,841 | 隔出一些时间我会看到你 |
| 00:35:51,121 | 很快 |
| 00:36:06,181 | 好的欢迎回来你找到了吗 |
| 00:36:08,580 | bug你的测试看起来怎么样如果你 |
| 00:36:11,101 | 运行Forge coverage它看起来 |
| 00:36:14,101 | 至少像这样它看起来更好吗 |
| 00:36:16,681 | 更糟 |
| 00:36:17,761 | 所以我复制粘贴了一大堆我的 |
| 00:36:19,681 | 测试我们看起来相当不错这里 |
| 00:36:21,920 | 我们肯定应该提高 |
| 00:36:24,241 | 我们分支的测试覆盖率我们可以 |
| 00:36:26,221 | 肯定让这些高一点 |
| 00:36:27,901 | 但至少对于DSC engine |
| 00:36:30,301 | 我们有一个好得多的代码覆盖率 |
| 00:36:32,341 | 在这里 |
| 00:36:33,661 | 我希望你的代码覆盖率看起来像 |
| 00:36:35,101 | 看起来也像这样现在另外我 |
| 00:36:37,500 | 做了一点重构写 |
| 00:36:39,241 | 这些代码 |
| 00:36:40,201 | 我添加的主要事情之一是 |
| 00:36:42,181 | 我添加了这个calculate health Factor |
| 00:36:44,701 | 函数 |
| 00:36:45,601 | 我添加这个calculate health的原因 |
| 00:36:47,281 | Factor internal函数是这样我 |
| 00:36:50,221 | 可以有这个public calculate Health |
| 00:36:52,261 | Factor函数然后在我的测试中 |
| 00:36:54,121 | 我可以做的是有一个expected |
| 00:36:56,401 | Health Factor |
| 00:36:57,841 | 这样当 |
| 00:36:59,761 | 一个函数破坏Health factor并且我 |
| 00:37:02,460 | 可以把它传递到expected Health |
| 00:37:04,261 | Factor error revert这里在我的一个 |
| 00:37:06,960 | 测试中对吧当我们测试来expect |
| 00:37:09,000 | 一个event我添加了这个新函数来做 |
| 00:37:11,821 | 那个并且有一个public函数像 |
| 00:37:14,101 | calculate health Factor可能使它 |
| 00:37:16,021 | 更容易让人们 |
| 00:37:17,641 | 看到他们的health Factor如果可能是什么 |
| 00:37:19,861 | 他们做一些改变对吧所以那是 |
| 00:37:21,601 | 我做的大的之一并且bug |
| 00:37:23,701 | 也在health Factor中或至 |
| 00:37:27,060 | 少我计划在那里的bug |
| 00:37:29,101 | 在那里所以在我的calculate Health factor |
| 00:37:31,380 | 不是在 |
| 00:37:33,901 | 我们的underscore health |
| 00:37:35,880 | Factor函数我只是调用这个 |
| 00:37:38,880 | calculate health Factor函数对吧 |
| 00:37:40,441 | 我得到account information并且 |
| 00:37:41,941 | 然后只是把它传递给这个calculate |
| 00:37:43,261 | Health factor在这个里我们需要 |
| 00:37:46,021 | 添加一个检查器如果total DSC |
| 00:37:48,841 | minted是零并且如果是零那么我们 |
| 00:37:52,141 | 说好酷你的health factor |
| 00:37:53,701 | 将是max uint256或者 |
| 00:37:55,380 | 类似的东西对吧并且原因 |
| 00:37:57,060 | 我们需要这个是 |
| 00:37:59,040 | 如果有人deposit大量抵押品 |
| 00:38:01,080 | 但没有minted DSC好他们的health |
| 00:38:04,801 | factor将除以零这 |
| 00:38:07,741 | 我们不能有所以计算某人的 |
| 00:38:09,721 | Health Factor在deposit之后 |
| 00:38:11,101 | collateral会导致一个问题我们会 |
| 00:38:13,380 | 破坏东西我们不想破坏东西 |
| 00:38:15,481 | 然后我做的最后一件事是 |
| 00:38:17,880 | 我添加了一大堆external view函数 |
| 00:38:21,241 | 只是为了使它更容易读取和 |
| 00:38:22,920 | 与这个协议交互所以那些是 |
| 00:38:25,621 | 我做的一些重构然后 |
| 00:38:27,241 | 显然我们添加了一大堆测试 |
| 00:38:29,040 | 这里真的没有什么新的 |
| 00:38:31,500 | 只是你得写测试对吧 |
| 00:38:34,141 | 这里的一切你都学过
