# 1 清算流程

> 实现 liquidate 函数：检查 health factor < 1，计算带 10% 奖励的债务。

| 时间戳 | 内容 |
| :--- | :--- |
| 00:00:00,000 | 我们还没有详细讨论过 |
| 00:00:01,620 | 这个去中心化稳定币 |
| 00:00:03,719 | 就像我说的，它是 ownable 的，但需要 |
| 00:00:06,120 | 被 engine 拥有，所以这个 ownable |
| 00:00:08,460 | 实际上有一个 transfer ownership |
| 00:00:11,520 | 函数，我们要调用它 |
| 00:00:13,920 | 把所有权转移给 engine |
| 00:00:16,560 | 我们回到部署脚本这里，哦 |
| 00:00:18,298 | 抱歉，这不是 DSC |
| 00:00:20,298 | address DSC，然后我们要调用 |
| 00:00:24,560 | DSC.transfer ownership 到 |
| 00:00:29,699 | address DSC engine，现在只有 engine |
| 00:00:33,840 | 哎呀，engine，抱歉，只有 engine |
| 00:00:37,320 | 可以操作它 |
| 00:00:38,940 | 然后我们要返回所有这些 |
| 00:00:40,380 | return |
| 00:00:41,940 | DSC 和 engine，很好，哦，deployer |
| 00:00:46,140 | key 要放在这里 |
| 00:00:51,120 | 好的，很好，所以我们做这一切的原因 |
| 00:00:53,219 | 是因为我想用 |
| 00:00:55,320 | 实际的部署脚本来编写单元测试 |
| 00:00:57,239 | 因为我更喜欢这样做，但就像我说的 |
| 00:00:59,460 | 你可能最好先写单元测试 |
| 00:01:01,080 | 在你写 |
| 00:01:02,340 | 部署脚本之前 |
| 00:01:03,840 | 然后用你的部署脚本做集成测试 |
| 00:01:05,460 | 但无论如何，让我们 |
| 00:01:08,159 | 终于在这里创建一个测试 |
| 00:01:10,520 | DSC engine test.t.sol |
| 00:01:14,699 | 记住我们做这一切的全部原因，我知道我们一直在写代码 |
| 00:01:17,580 | 是在 DSC engine 中我们添加了 |
| 00:01:21,239 | 一大堆函数，其中一些 |
| 00:01:23,039 | 比如 get USD value 我们肯定想检查 |
| 00:01:24,840 | get collateral account |
| 00:01:26,699 | value，我们要确保 minting 工作正常 |
| 00:01:28,980 | 我们的 Constructor 正常，depositing 正常 |
| 00:01:31,320 | 等等，所以我们边做边测试 |
| 00:01:33,600 | 就像我说的，当我实际编码时 |
| 00:01:35,699 | 我确实写了测试 |
| 00:01:37,920 | 我也写了部署脚本，因为我 |
| 00:01:40,980 | 想在进行时测试，对吧，我 |
| 00:01:43,140 | 不想事后回去 |
| 00:01:45,179 | 重构和重写我的代码，如果我犯了 |
| 00:01:47,880 | 一些明显的错误，在构建时测试真的很好 |
| 00:01:51,600 | 说实话我觉得这让我更快 |
| 00:01:53,520 | 因为我更有信心 |
| 00:01:55,020 | 我所做的是正确的 |
| 00:01:57,360 | 在编码时，所以 spdx |
| 00:02:00,659 | license |
| 00:02:02,539 | identifier MIT pragma solidity |
| 00:02:07,880 | 0.8.18，这里加个小尖号，contract |
| 00:02:12,440 | DSC engine test is test |
| 00:02:16,920 | import test from Forge STD slash test |
| 00:02:22,080 | 都像这样，好的，很好 |
| 00:02:25,679 | function |
| 00:02:27,480 | setup |
| 00:02:28,980 | public 或 external，我们需要部署 |
| 00:02:33,060 | 部署我们的合约，或者我们要 |
| 00:02:35,940 | import |
| 00:02:36,960 | deploy DSC from dot slash dot slash |
| 00:02:41,520 | scripts slash deploy dsc.s.sol |
| 00:02:45,539 | deploy DSC deployer，我们说 |
| 00:02:49,798 | player equals new |
| 00:02:51,719 | deploy DSC，像这样，我又在这里用了很多 tab |
| 00:02:54,298 | 然后我们要说 |
| 00:02:55,739 | 我们需要 import |
| 00:02:57,360 | decentralized stablecoin from dot dot |
| 00:03:03,779 | slash dot slash SRC slash |
| 00:03:07,340 | decentralizedstablecoin.sol，我们也需要 |
| 00:03:08,940 | import engine，DSC engine from |
| 00:03:13,560 | 这里 GitHub copilot 真的能让你的生活轻松很多 |
| 00:03:15,600 | 只需在这里按 tab 键 |
| 00:03:17,219 | 或者你用的任何 AI |
| 00:03:19,679 | 现在我们要说 DSC，让我们实际上 |
| 00:03:22,080 | 让这些，我们说 decentralized |
| 00:03:24,900 | stablecoin DSC |
| 00:03:27,239 | 和 DSC engine |
| 00:03:29,400 | 我们叫 dsce |
| 00:03:31,620 | 这很令人困惑，你把这个叫 |
| 00:03:34,620 | engine 或其他什么，我要叫我的 |
| 00:03:36,360 | DSE，所以现在我们的 deploy 返回 DSC 和 |
| 00:03:38,159 | engine |
| 00:03:43,679 | 所以我要说 return DSC, dsce |
| 00:03:44,640 | equals deployer.run，好的，看起来 |
| 00:03:48,659 | 很不错 |
| 00:03:51,659 | 我们还有很多事情要做 |
| 00:03:52,500 | 但至少我们设置好了测试 |
| 00:03:54,420 | 我们想做的第一个测试是 |
| 00:03:56,279 | 这个 price feed 测试，对吧 |
| 00:03:58,620 | 我们要确保这个 get USD value |
| 00:04:01,560 | 我们在这里做的数学运算 |
| 00:04:04,380 | 因为我们在做一些奇怪的数学 |
| 00:04:06,298 | 我们要确保这真的能正常工作 |
| 00:04:07,860 | 所以我要做，我要 |
| 00:04:09,000 | 设置一个小的 price feeds |
| 00:04:11,940 | Test Section，price tests，像这样 |
| 00:04:13,259 | 我们说 function test get USD value |
| 00:04:17,759 | 在这里我们要测试我们的 get USD |
| 00:04:24,960 | value 函数，所以它接受 token |
| 00:04:27,840 | address 和 amount，所以我们需要 |
| 00:04:29,699 | 获取我们用来部署的那些 tokens |
| 00:04:31,860 | 我们可以很容易地从 |
| 00:04:34,739 | helper config 中获取，所以我们可以做的是 |
| 00:04:35,940 | 在我们的 deploy 中也让它 |
| 00:04:38,039 | 返回 config |
| 00:04:39,600 | 在底部我们也 |
| 00:04:42,420 | 返回 config |
| 00:04:47,219 | comma config |
| 00:04:49,080 | config 是 helper config |
| 00:04:51,900 | helper config config，import 它 |
| 00:04:53,699 | import helper config from dot dot script |
| 00:04:55,679 | double config.s.sol |
| 00:05:00,239 | 好的，很好，现在我们可以获取 |
| 00:05:03,299 | weth |
| 00:05:06,600 | address，我们也可以获取 eth USD |
| 00:05:10,799 | 我们把这些放在顶部 |
| 00:05:12,719 | 我们说 |
| 00:05:17,100 | address eth USD price feed |
| 00:05:19,320 | 我们说 address |
| 00:05:20,759 | weth，我们从 helper config 获取 |
| 00:05:24,299 | 所以这是前两个 |
| 00:05:26,460 | 所以是 eth USD price feed，bitcoin price |
| 00:05:28,380 | feed 在这里，所以 comma weth, comma 这是 |
| 00:05:30,360 | Bitcoin token, comma 这是 deployer |
| 00:05:34,380 | key equals config.dot |
| 00:05:37,259 | Active network config，很好，我们有 |
| 00:05:39,480 | price feed 和 weth，所以现在我们 |
| 00:05:43,159 | 终于可以下来设置这个 |
| 00:05:46,980 | 函数了，所以我们说 uint256 eth |
| 00:05:49,020 | amount equals，比如说有 15 eth |
| 00:05:51,000 | 对吧，15 eth，如果我们有 15 eth |
| 00:05:53,520 | 乘以两千美元 |
| 00:05:57,060 | 或 eth 等于什么，三万 |
| 00:06:01,980 | 可能三万 e |
| 00:06:04,620 | 18，对吧，很简单的数学，所以 |
| 00:06:08,400 | 让我们做 uint256 expected USD equals |
| 00:06:10,620 | 三，三万一千二百，三万美元 |
| 00:06:14,400 | 三万美元 |
| 00:06:18,900 | 然后我们说 uint256 actual USD |
| 00:06:21,659 | equals dsce.dot get USD value, weth 和 |
| 00:06:22,980 | eth amount，这应该能工作的原因是 |
| 00:06:26,580 | 因为在我们的 engine 中我们传入 |
| 00:06:33,060 | token 和 amount，在内部它使用 |
| 00:06:35,759 | 与该 token 关联的 price feed |
| 00:06:37,620 | 调用 price 来获取金额 |
| 00:06:40,440 | 现在我们应该能够做一个 |
| 00:06:42,960 | assert |
| 00:06:44,159 | equals expected USD |
| 00:06:47,100 | 和 actual USD，好的，我知道有 |
| 00:06:49,199 | 很多设置才能写这一个测试 |
| 00:06:52,259 | 但就像我说的，我喜欢确保 |
| 00:06:55,799 | 我的部署脚本从一开始就是 |
| 00:06:57,120 | 测试套件的一部分 |
| 00:06:58,920 | 但把它们作为集成测试可能是个好主意 |
| 00:07:01,080 | 所以 forge test |
| 00:07:02,520 | dash m test get USD value |
| 00:07:04,440 | 它工作了，现在我要指出 |
| 00:07:07,440 | 我第一次运行这个测试时 |
| 00:07:11,940 | 我实际上失败得很惨，我搞错了 |
| 00:07:14,759 | 很多东西，这没关系 |
| 00:07:16,380 | 因为你也会，这就是为什么 |
| 00:07:19,739 | 你要写测试，所以我在这里的时候 |
| 00:07:21,179 | 让我们也至少写一个 deposit |
| 00:07:22,620 | collateral 测试，让我复制这个 |
| 00:07:24,840 | 粘贴在这里，因为我们要 |
| 00:07:27,480 | 写很多 deposit collateral，deposit collateral |
| 00:07:30,299 | tests，让它看起来漂亮一点 |
| 00:07:34,679 | 至少那样 |
| 00:07:37,320 | 我们做一些更简单的测试 |
| 00:07:40,020 | function test revert，reverts if |
| 00:07:42,900 | collateral |
| 00:07:45,179 | zero |
| 00:07:48,659 | public |
| 00:07:50,520 | 我们要 prank 一个 user，所以在顶部 |
| 00:07:52,080 | 我们做一个 address public user equals |
| 00:07:53,460 | make address user |
| 00:07:56,580 | 像这样，user 大写 |
| 00:07:59,940 | user |
| 00:08:03,659 | 让我们说 vm.start prank user，现在 |
| 00:08:08,000 | 至少会批准 token 可以进入 |
| 00:08:09,840 | 协议，所以我们做 erc20 mock |
| 00:08:15,539 | weth |
| 00:08:19,080 | 我们导入了吗，没有，我们要 |
| 00:08:22,620 | import 它，import erc20 mock |
| 00:08:24,179 | from |
| 00:08:26,279 | at openzeppelin slash contracts |
| 00:08:29,400 | slash |
| 00:08:31,020 | 是什么，mocks slash 或 contracts mocks |
| 00:08:34,440 | erc20 mock，好的，erc20 mock.sol |
| 00:08:35,520 | erc20 mock weth.dot approve |
| 00:08:39,179 | address dsce，某个 amount，让我们在 |
| 00:08:43,679 | 顶部做另一个 uint256 |
| 00:08:48,840 | public constant amount |
| 00:08:54,540 | collateral equals |
| 00:08:57,779 | 比如说 10 ether 的 collateral |
| 00:09:01,699 | 在这里我们批准那 10 |
| 00:09:04,980 | collateral，然后我们做 |
| 00:09:08,580 | vm.expect |
| 00:09:11,040 | revert |
| 00:09:14,179 | with DSC engine |
| 00:09:15,900 | dot，我们需要使用 |
| 00:09:17,340 | needs more than zero 在这里，needs more |
| 00:09:19,400 | than zero |
| 00:09:21,840 | dot selector，现在你们知道 |
| 00:09:24,540 | selector 这个部分的意思了 |
| 00:09:26,159 | dsce.dot deposit collat，collateral |
| 00:09:28,380 | 比如说 weth, zero，像这样，然后 vm.stop |
| 00:09:29,960 | prank，实际上这可能会因为 |
| 00:09:35,640 | 不同的原因失败，但让我们试一下 |
| 00:09:40,440 | forge test dash m |
| 00:09:43,199 | M，好的，很好，这实际上通过了 |
| 00:09:44,759 | 现在如果我们想让这个测试更好一点 |
| 00:09:50,279 | 我们也应该 mint 给我们的 |
| 00:09:52,259 | user 一些 weth，我们可能应该 |
| 00:09:54,120 | 在 setup 中做这个，这样我们就不用 |
| 00:09:57,120 | 为每个测试都做一次 |
| 00:10:00,540 | 我要做的是 |
| 00:10:01,860 | 我要做 erc20 mock, weth.dot |
| 00:10:04,020 | mint user，我们要做一个 uint256 |
| 00:10:05,880 | 我们让它成为 constant |
| 00:10:10,259 | starting erc20. |
| 00:10:14,820 | balance |
| 00:10:17,040 | balance |
| 00:10:20,520 | equals |
| 00:10:22,140 | 让我们说这也是 10 ether |
| 00:10:23,580 | ether starting erc20 balance |
| 00:10:25,500 | boom，好的，很好，所以现在 forge test |
| 00:10:27,299 | 我们所有的测试都通过了，很好 |
| 00:10:30,900 | 就像我说的，我会做这个作为 |
| 00:10:34,739 | 健全性检查，以确保我的 |
| 00:10:37,500 | 架构甚至是有意义的，对吧 |
| 00:10:39,000 | 所以我们接下来可能也想做的是 |
| 00:10:40,980 | 对 collateral 进行测试 |
| 00:10:43,259 | 是否被存入这些数据结构 |
| 00:10:45,779 | 但现在我对这些测试感到满意 |
| 00:10:49,020 | 所以我只是要回去 |
| 00:10:50,759 | 写我的合约，就像我说的 |
| 00:10:53,219 | 没有一个单一的流程 |
| 00:10:55,080 | 我不认为我曾经一次性 |
| 00:10:58,139 | 完整地写完一个智能合约 |
| 00:11:00,480 | 我几乎总是 |
| 00:11:03,299 | 在写代码的同时写测试 |
| 00:11:05,699 | 所以这样做真的是个好主意 |
| 00:11:08,040 | 是的，你不必在写代码时 |
| 00:11:10,440 | 写部署脚本 |
| 00:11:12,840 | 但这是我喜欢做的 |
| 00:11:15,060 | 然后你知道吗，当我们写这些测试时 |
| 00:11:16,199 | 让我们也做 dash |
| 00:11:18,060 | dash fork URL，所以 sepolia RPC URL，让我们 |
| 00:11:20,699 | 也这样做 |
| 00:11:26,100 | 因为这可能会失败 |
| 00:11:27,360 | 因为我们不能凭空 mint weth |
| 00:11:30,299 | 我们确实失败了，test get |
| 00:11:33,840 | USD value，哦有趣，这是那个 |
| 00:11:36,239 | 失败的，test get USD value，啊这个 |
| 00:11:38,040 | 失败是因为我们硬编码了 |
| 00:11:40,860 | expected USD 就在这里 |
| 00:11:43,799 | 当然 sepolia 上的价格是 |
| 00:11:46,139 | 实际价格，而不是我们编造的 |
| 00:11:48,600 | 这个假价格，所以我们可能应该 |
| 00:11:50,400 | 更新这个测试让它更不可知 |
| 00:11:52,440 | 对吧，我们可能应该更新这个测试 |
| 00:11:54,600 | 这样不是只在这里硬编码 3000 |
| 00:11:57,659 | 更新这个测试使用 |
| 00:11:58,980 | 实际 price feed 的价格 |
| 00:12:01,139 | 现在我要保持原样 |
| 00:12:03,060 | 然后我可以稍后修复它 |
| 00:12:04,980 | 用于运行那些 fork 测试 |
| 00:12:06,600 | 所以我们现在在哪里？好的，我们有 |
| 00:12:11,940 | 存入 collateral 的方法，我们有 |
| 00:12:14,520 | mint 的方法，我们这里没有太多测试 |
| 00:12:16,920 | 我们只是假设这 |
| 00:12:19,020 | 目前能工作，这还行，但 |
| 00:12:21,060 | 这很好，对吧，我们有进展了 |
| 00:12:23,460 | 所以我们可以 mint 我们的债务或我们的 DSC |
| 00:12:24,900 | 我们现在实际上可以获取大量信息 |
| 00:12:30,000 | 这很棒，让我们现在把这两个组合成 |
| 00:12:32,100 | 这个主要函数 |
| 00:12:33,719 | 我们认为很多人会调用的 |
| 00:12:37,199 | 这个 deposit collateral and mint DSC |
| 00:12:38,699 | 对吧，这个协议的目的是 |
| 00:12:39,900 | mint 这个稳定币，对吧，deposit |
| 00:12:44,040 | collateral and mint DSC，这只是 |
| 00:12:46,500 | deposit collateral 和 mint DSC 的组合 |
| 00:12:49,020 | 所以在这里，这个 |
| 00:12:51,060 | 要接收类似于 |
| 00:12:53,040 | deposit collateral 的东西，address |
| 00:12:56,639 | token collateral address |
| 00:12:58,080 | 一个 uint256 amount collateral，然后 |
| 00:13:00,000 | 也是一个 uint256 amount DSC to mint |
| 00:13:02,520 | 对吧，在这里我们只是要调用 |
| 00:13:06,540 | deposit collateral 现在是 external |
| 00:13:10,380 | 对吧，我们把这个改成 public |
| 00:13:15,659 | 函数 |
| 00:13:18,060 | 所以我们把这改成 deposit |
| 00:13:20,639 | collateral |
| 00:13:22,620 | 或者我们给它 token collateral |
| 00:13:23,880 | address 和 amount collateral |
| 00:13:26,759 | 然后我们调用 mint DSC, amount |
| 00:13:28,860 | DSC to mint，boom，所以这个函数做的就是 |
| 00:13:31,500 | 把这两个组合在一起 |
| 00:13:34,139 | mint DSC，mint DSC 没有 |
| 00:13:37,679 | 定义，因为它是 external，我们把 |
| 00:13:40,139 | 这个也改成 public，这样我们的合约 |
| 00:13:41,759 | 也可以调用它，toggle word wrap |
| 00:13:46,080 | 把那个放回去，好的，很好，所以这是 |
| 00:13:48,480 | 我们的主要函数之一 |
| 00:13:51,480 | 我们这样想，所以让我们添加一些 natspec |
| 00:13:53,340 | 我们说 at param，这是 |
| 00:13:55,320 | GitHub copilot 真的很有帮助的地方 |
| 00:13:56,699 | token collateral address，要存入的 token 地址作为 collateral，at |
| 00:13:58,739 | param amount collateral，是的，at param |
| 00:14:02,639 | 那个看起来也不错，然后我们添加 |
| 00:14:05,100 | notice，这个函数将存入你的 |
| 00:14:06,900 | collateral |
| 00:14:09,179 | 并在一次 |
| 00:14:12,239 | 交易中 mint DSC |
| 00:14:14,639 | 对吧，因为否则我们要让 |
| 00:14:19,139 | 人们调用 deposit collateral 然后 mint |
| 00:14:20,520 | 但有些人可能只想 |
| 00:14:24,960 | 同时做这两件事，因为这是 |
| 00:14:26,340 | 这个协议的目的 |
| 00:14:27,840 | 好的，很好，所以我们有办法让人们 |
| 00:14:29,279 | 把钱存入，他们怎么取出钱呢 |
| 00:14:32,278 | 所以我们需要写 |
| 00:14:34,380 | 这个 redeem collateral，对吧，为了 |
| 00:14:39,359 | 他们赎回 collateral，让我们谈谈 |
| 00:14:41,340 | 这个，为了赎回 collateral |
| 00:14:43,800 | 他们需要什么，一 |
| 00:14:45,720 | 他们的 health factor |
| 00:14:48,720 | 必须在 |
| 00:14:50,698 | collateral 取出后大于一 |
| 00:14:55,380 | 所以我们要在这里做一些检查 |
| 00:14:57,480 | 以确保他们在这里有足够的钱 |
| 00:15:00,060 | 这是主要的事情，对吧 |
| 00:15:03,320 | 这是我们真正需要担心的 |
| 00:15:05,999 | 所以让我们开始写这个 |
| 00:15:07,380 | 首先我们应该让他们选择 |
| 00:15:09,480 | 他们想要哪个 collateral，所以 address |
| 00:15:11,159 | token collateral address |
| 00:15:12,600 | 然后显然是 amount, amount |
| 00:15:15,958 | collateral |
| 00:15:18,300 | 我们要在这里为 |
| 00:15:20,519 | amount collateral 添加这个 more |
| 00:15:23,760 | than zero modifier |
| 00:15:26,458 | 我们不希望他们 |
| 00:15:27,778 | 发送意外的零交易 |
| 00:15:29,820 | 因为我们要移动 |
| 00:15:32,340 | tokens，我们就做 |
| 00:15:33,840 | non-reentrant，安全总比抱歉好 |
| 00:15:36,198 | 我们可以稍后在 gas 审计中找出 |
| 00:15:39,118 | 这是否真的需要 |
| 00:15:40,560 | 现在我要写这个函数，就好像 |
| 00:15:44,579 | 某人赎回 collateral 是 |
| 00:15:48,778 | 他们实际赎回 collateral 的唯一时间 |
| 00:15:50,880 | 然而我们要 |
| 00:15:52,079 | 在将来重构这个，使我们的 |
| 00:15:53,880 | 代码更加模块化，有这个 |
| 00:15:56,278 | 计算机科学中的概念叫 DRY |
| 00:15:59,159 | don't repeat yourself，如果你发现 |
| 00:16:01,140 | 自己编写相同的东西 |
| 00:16:04,800 | 应该在你脑海中点亮一个灯泡 |
| 00:16:06,300 | 哦，也许我正在做的不是 |
| 00:16:07,560 | 最佳实践 |
| 00:16:09,778 | 所以我们要用一种方式编码 |
| 00:16:11,038 | 然后 |
| 00:16:13,560 | 我现在告诉你，我们要 |
| 00:16:14,340 | 回去重构这个 |
| 00:16:15,720 | 在将来，但我想首先用这种方式编码 |
| 00:16:17,159 | 只是为了向你展示 |
| 00:16:19,320 | 你可能会经历的过程 |
| 00:16:22,260 | 以及当你自己遇到这个时 |
| 00:16:23,519 | 你可能会如何重构它 |
| 00:16:25,560 | 所以我们现在要用一种方式编码 |
| 00:16:27,359 | 让我们做吧，我们需要取出 |
| 00:16:28,499 | collateral，我们要更新 |
| 00:16:30,480 | 我们的内部账户，所以我们有这个 s underscore |
| 00:16:31,980 | collateral deposited of message.sender |
| 00:16:33,659 | of token collateral address，对吧 |
| 00:16:37,800 | 这是我们的内部账户 |
| 00:16:41,340 | 他们添加了多少 collateral，我们要 |
| 00:16:43,618 | minus equals amount |
| 00:16:45,180 | collateral，所以这假设我们要 |
| 00:16:47,760 | 取出它，如果他们尝试取出 |
| 00:16:49,380 | 超过他们拥有的，我们 |
| 00:16:51,480 | 稍微依赖 solidity 编译器 |
| 00:16:53,820 | 抛出错误，对吧，如果在 |
| 00:16:55,680 | 他们的余额中有一百 |
| 00:16:58,320 | 他们减去尝试取出一千，对吧 |
| 00:16:59,579 | 它会 revert，因为 |
| 00:17:01,439 | 从 solidity 的新版本开始 |
| 00:17:04,380 | 它们不让你做这种不安全的数学 |
| 00:17:07,198 | 这很棒，为我们节省了很多 |
| 00:17:09,239 | 麻烦，所以然后既然我们在更新 |
| 00:17:11,640 | State，我们要 emit 一个 event，让我们 |
| 00:17:14,100 | 叫它 collateral redeemed |
| 00:17:17,100 | 我们说它是 message.sender，所以 from |
| 00:17:20,640 | message.sender, amount collateral |
| 00:17:24,840 | token collateral address |
| 00:17:28,698 | 像这样 |
| 00:17:33,118 | 所以我们要去顶部 |
| 00:17:34,499 | 我们也要重构这个 event |
| 00:17:36,480 | 但你会明白为什么稍后，event |
| 00:17:38,159 | collateral redeemed, address indexed user |
| 00:17:40,618 | address indexed token |
| 00:17:44,340 | uint256 indexed amount，像这样 |
| 00:17:48,239 | 好的，control minus，直接回到 |
| 00:17:52,740 | 我们所在的地方，好的，amount collateral，哦 |
| 00:17:55,560 | 这有什么问题，哦这些 |
| 00:17:58,199 | 反了 |
| 00:18:00,120 | 好的，很好，所以现在 |
| 00:18:05,038 | 我们所要做的就是返还钱 |
| 00:18:07,499 | 那我们怎么做呢 |
| 00:18:10,740 | 所以我们想遵循 CEI，对吧，checks |
| 00:18:13,260 | effects interactions，checks, effects |
| 00:18:17,038 | interactions，但我们也想确保 |
| 00:18:19,560 | 在 collateral 被取出后 |
| 00:18:22,800 | health factor 是好的，这 |
