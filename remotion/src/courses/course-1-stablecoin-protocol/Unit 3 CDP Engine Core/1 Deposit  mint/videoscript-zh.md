# 1 存入与mint

> 实现depositCollateralAndMintDsc：CEI模式、moreThanZero和isAllowedToken修饰符。

| 时间戳 | 内容 |
| :--- | :--- |
| 00:00:00,000 | 价值要大于DSC的数量 |
| 00:00:04,500 | 这显然会涉及到 |
| 00:00:06,779 | 很多事情，对吧，它会 |
| 00:00:07,918 | 涉及价格预言机，我们将 |
| 00:00:10,438 | 检查价值 |
| 00:00:12,000 | 我们会检查很多东西 |
| 00:00:13,380 | 好的，所以这实际上会是一个 |
| 00:00:15,239 | 更深入一点的函数 |
| 00:00:17,099 | 在这里 |
| 00:00:17,880 | 所以让我们创建这个mint DSC函数 |
| 00:00:19,800 | 我们会让它传入一个 |
| 00:00:22,260 | uint256的amount DSC to Mint，这样人们可以 |
| 00:00:27,059 | 选择他们想要mint多少DSC，所以 |
| 00:00:29,340 | 比如说有人存入 |
| 00:00:31,559 | 价值200的ETH，也许他们只想 |
| 00:00:34,319 | mint价值20的DSC，对吧，所以他们可以 |
| 00:00:37,438 | 在这里选择他们想要mint多少 |
| 00:00:39,359 | 所以amount to Mint，让我们添加 |
| 00:00:42,300 | 一些检查，我们应该让他们 |
| 00:00:43,978 | mint多于零的amount DSC to Mint |
| 00:00:47,639 | 这个 |
| 00:00:49,139 | 还有什么，我们可能希望这个是 |
| 00:00:51,000 | 非重入的，即使我们可能 |
| 00:00:53,219 | 不需要这个不可重入 |
| 00:00:54,840 | 因为这是我们的DSC代币，但让我们 |
| 00:00:58,319 | 还是把它放在这里 |
| 00:00:59,579 | 这可能是我们现在需要的全部，我们 |
| 00:01:01,679 | 可能想做一些 |
| 00:01:04,978 | 看起来GitHub Copilot甚至给了我 |
| 00:01:07,319 | 一些遵循CEI的，是的，哦那个是 |
| 00:01:10,199 | 错的，amount DSC to Mint，amount DSC to |
| 00:01:14,519 | Mint，要mint的去中心化 |
| 00:01:18,659 | 稳定币数量，注意 |
| 00:01:22,619 | 他们 |
| 00:01:24,119 | 必须有比最低阈值更多的collateral价值 |
| 00:01:29,639 | 我们将 |
| 00:01:33,239 | 在一秒钟内弄清楚那是什么意思 |
| 00:01:34,319 | 所以mint DSC需要跟踪 |
| 00:01:37,319 | 每个人mint了多少，对吧，所以 |
| 00:01:39,779 | 每当他们mint DSC时，他们在 |
| 00:01:41,279 | 某种程度上是在mint债务，对吧，所以 |
| 00:01:42,898 | 我们需要跟踪那个 |
| 00:01:44,519 | 我们可以在哪里做到这一点？我们可以在 |
| 00:01:46,500 | 状态变量中做到 |
| 00:01:47,938 | 所以我们会做一个mapping |
| 00:01:52,139 | 地址 |
| 00:01:54,319 | 映射到 |
| 00:01:56,099 | 他们的uint256，这将是 |
| 00:01:58,380 | 地址用户映射到uint |
| 00:02:01,019 | amount DSC minted，这将是 |
| 00:02:05,938 | private s下划线 |
| 00:02:08,059 | DSC minted，现在我可以回到 |
| 00:02:12,418 | 这里，用这个新的mapping，s DSC minted |
| 00:02:16,519 | msg.sender加等于amount DSC |
| 00:02:20,938 | to Mint，所以我们要跟踪 |
| 00:02:23,340 | 他们mint的所有东西，再次，这将 |
| 00:02:25,199 | 遵循CEI |
| 00:02:26,938 | 所以现在我们想在这里做一个小检查 |
| 00:02:28,500 | 如果他们mint了 |
| 00:02:30,359 | 太多，例如mint了150 |
| 00:02:35,099 | 或者价值150的DSC，但他们只有 |
| 00:02:38,219 | 价值100的ETH，那将是太 |
| 00:02:41,099 | 多了，如果发生这种情况 |
| 00:02:44,340 | 我们应该100%回滚 |
| 00:02:45,179 | 所以我实际上要创建一个函数 |
| 00:02:47,159 | 我要创建一个内部函数 |
| 00:02:48,659 | 叫做revert if |
| 00:02:52,019 | Health factor is broken，传入 |
| 00:02:57,019 | msg.sender，所以我们 |
| 00:02:59,878 | 要创建这个新的内部 |
| 00:03:01,139 | 函数，所以在这里我们有external |
| 00:03:03,119 | 函数，我们要向下滚动 |
| 00:03:04,978 | 到这里，我们要创建这个 |
| 00:03:07,679 | private和internal函数 |
| 00:03:10,918 | 像这样，我们只能 |
| 00:03:14,519 | 在内部调用这个 |
| 00:03:16,378 | 对吧，所以我们要创建这个 |
| 00:03:17,819 | 函数，function revert if Health |
| 00:03:19,559 | factor is broken |
| 00:03:21,300 | address user，它将是一个 |
| 00:03:22,739 | internal view |
| 00:03:25,019 | 函数 |
| 00:03:26,579 | 我们基本上会做一件事，检查 |
| 00:03:27,958 | health |
| 00:03:31,319 | factor，基本上就是 |
| 00:03:32,398 | 他们有足够的collateral吗，对吧 |
| 00:03:34,739 | 然后如果他们没有好的 |
| 00:03:38,699 | health factor就回滚，所以这个health factor |
| 00:03:41,699 | 实际上是我从 |
| 00:03:44,760 | Aave文档中借来的一个术语 |
| 00:03:46,438 | 这些风险参数 |
| 00:03:48,000 | 使得health factor的计算成为可能 |
| 00:03:49,739 | 你可以看到一个小图片 |
| 00:03:51,840 | 展示它，所以此外我们 |
| 00:03:53,458 | 需要创建一个函数来 |
| 00:03:56,279 | 检查health factor，实际上这些 |
| 00:03:57,958 | 将是private internal view |
| 00:04:00,239 | 函数 |
| 00:04:02,279 | 所以首先我们需要创建一个可以 |
| 00:04:03,659 | 获取health factor的函数，所以我们 |
| 00:04:05,639 | 要在这里创建另一个函数叫做 |
| 00:04:07,500 | function |
| 00:04:09,119 | 下划线health factor，我们将 |
| 00:04:10,139 | 接受一个address user，你看我们有 |
| 00:04:13,438 | 这个前导下划线来告诉我们作为 |
| 00:04:16,260 | 开发者这是一个internal |
| 00:04:18,418 | 函数，所以让我们实际上给这个也加一个 |
| 00:04:20,279 | 下划线 |
| 00:04:22,978 | function，哎呀，health factor，这 |
| 00:04:24,478 | 将是一个private view |
| 00:04:28,559 | 我会返回一个uint256，所以 |
| 00:04:30,958 | 这个health factor的作用 |
| 00:04:34,139 | 是 |
| 00:04:35,579 | 给它一点nat spec，现在我们 |
| 00:04:36,300 | 可以说这将 |
| 00:04:39,359 | 返回用户离清算有多近 |
| 00:04:41,659 | 如果用户低于 |
| 00:04:46,619 | 1，那么 |
| 00:04:47,519 | 他们可以被清算，所以我们将 |
| 00:04:51,359 | 弄清楚用户可以拥有的 |
| 00:04:53,760 | collateral与mint的DSC的比率 |
| 00:04:56,819 | 通过这个health factor函数 |
| 00:04:58,679 | 我们将构建很多东西 |
| 00:05:01,500 | 在这里，所以为了弄清楚这个 |
| 00:05:03,059 | 我们需要什么？我们需要获取 |
| 00:05:04,739 | 两个东西 |
| 00:05:06,779 | 他们的总mint DSC，对吧 |
| 00:05:08,639 | 我们需要获取他们的总 |
| 00:05:09,659 | collateral |
| 00:05:13,859 | 价值，对吧，不仅仅是总 |
| 00:05:15,659 | collateral，我们需要获取 |
| 00:05:17,398 | 总collateral价值，确保 |
| 00:05:19,619 | 价值大于总mint的DSC |
| 00:05:20,699 | |
| 00:05:23,039 | 所以我们必须创建另一个 |
| 00:05:25,079 | 函数 |
| 00:05:26,219 | 我们需要获取uint256 |
| 00:05:27,840 | 总mint DSC和uint256 collateral |
| 00:05:28,800 | 价值以USD，我们要创建一个新 |
| 00:05:31,559 | 函数叫做get account information |
| 00:05:36,599 | 从那个用户那里，所以我们要做另一个 |
| 00:05:39,779 | 嘣，function下划线get account |
| 00:05:43,159 | information像这样，我们将接受一个 |
| 00:05:46,918 | address user，这将是一个private view |
| 00:05:51,000 | 我们将返回 |
| 00:05:54,359 | 两样东西，uint256 |
| 00:05:58,559 | 总mint DSC和uint256 |
| 00:06:01,378 | collateral value in USD，两个函数 |
| 00:06:03,539 | 在这里获取总USD很容易 |
| 00:06:07,579 | 对吧，我们只需要total DSC minted等于 |
| 00:06:11,819 | 这个数组，这可以是这个mapping |
| 00:06:14,039 | 我们刚创建的，对吧，我们正在 |
| 00:06:19,319 | 跟踪这个，所以我们要做的就是 |
| 00:06:22,139 | 这个，要获取总collateral |
| 00:06:23,519 | 价值以USD，我们需要做 |
| 00:06:25,079 | 更多的数学计算，所以我会说 |
| 00:06:27,239 | collateral value in USD等于 |
| 00:06:29,458 | get account collateral |
| 00:06:31,378 | value |
| 00:06:35,639 | 我们将传入一些user，所以 |
| 00:06:38,519 | 这将是一个不同的函数 |
| 00:06:39,779 | 我们将把这个设为public |
| 00:06:41,938 | 函数，这样任何人都可以调用这个 |
| 00:06:44,398 | 函数 |
| 00:06:46,079 | 所以我们实际上要复制这个 |
| 00:06:48,059 | private和view internal函数 |
| 00:06:49,438 | public internal view，然后我们 |
| 00:06:51,840 | 要做view和pure public以及 |
| 00:06:54,059 | external函数，一直到 |
| 00:06:55,978 | 底部，所以我们会说private |
| 00:06:58,319 | 而不是我们会说public |
| 00:06:59,579 | 和external view函数，我们会做 |
| 00:07:01,978 | function |
| 00:07:03,898 | get account |
| 00:07:07,619 | collateral value，用户的地址，这 |
| 00:07:08,519 | 将是一个public view，所以任何人都可以 |
| 00:07:10,319 | 调用它，返回一个uint256，跟着我 |
| 00:07:14,819 | 我知道我们有点深入这个 |
| 00:07:16,559 | 树，跟着我，我们即将走得 |
| 00:07:21,359 | 更远 |
| 00:07:22,500 | 现在要获取实际价值我们 |
| 00:07:24,719 | 需要做什么？我们需要遍历每个 |
| 00:07:25,800 | collateral代币 |
| 00:07:27,719 | 获取他们存入的数量 |
| 00:07:29,760 | 并将其映射到 |
| 00:07:31,500 | 价格以获取USD价值 |
| 00:07:33,239 | 所以我们要遍历所有 |
| 00:07:36,478 | collateral代币，哦哦，我们有一个方法 |
| 00:07:38,699 | 可以做到这一点，让我们滚动到顶部，我们有 |
| 00:07:43,378 | 价格预言机的mapping，但我们 |
| 00:07:45,300 | 没有办法遍历它们，所以 |
| 00:07:48,779 | 我们可以做什么 |
| 00:07:51,539 | 是我们可以只有像你知道的 |
| 00:07:53,819 | address WETH然后address |
| 00:07:56,039 | wrapped BTC，我们可以只有两个 |
| 00:07:57,300 | 代币像这样，我们不需要遍历 |
| 00:07:59,458 | 任何东西，我们要让这个系统更通用一点 |
| 00:08:03,679 | 这样你就可以部署这个与任意数量的 |
| 00:08:06,599 | 稳定币，任意数量的 |
| 00:08:08,039 | collateral，所以 |
| 00:08:09,599 | 我们要创建一个新的状态变量 |
| 00:08:11,938 | 它将是一个address数组 |
| 00:08:13,619 | private s下划线collateral tokens |
| 00:08:15,559 | 我们要做的是在 |
| 00:08:17,819 | 构造函数中，当我们用代币和价格预言机更新我们的价格 |
| 00:08:19,739 | 预言机时 |
| 00:08:21,958 | 我们还要添加代币的 |
| 00:08:25,918 | 地址 |
| 00:08:27,719 | 到这个数组，现在我们有这个 |
| 00:08:30,539 | collateral代币数组，我们可以 |
| 00:08:33,119 | 遍历，这样我们就可以 |
| 00:08:35,699 | 根据所有代币计算人们有多少价值 |
| 00:08:36,958 | |
| 00:08:40,378 | 所以 |
| 00:08:41,878 | get account collateral value，我们将 |
| 00:08:43,378 | 说for uint256 i等于0，i |
| 00:08:45,239 | 小于 |
| 00:08:47,878 | s collateral tokens点length，i加加，address |
| 00:08:49,139 | token等于s collateral tokens[i] |
| 00:08:51,599 | 我们会获取数量，所以这是 |
| 00:08:56,099 | 我们正在处理的代币，我们会获取 |
| 00:08:57,540 | 这个用户存入的数量，uint256 amount |
| 00:09:02,639 | 等于s下划线 |
| 00:09:07,800 | collateral deposited[user] |
| 00:09:10,438 | [token]像这样 |
| 00:09:12,000 | 然后total collateral |
| 00:09:15,958 | value in USD |
| 00:09:18,239 | 加等于，哦哦，现在我们有了 |
| 00:09:22,438 | 数量，我们需要获取 |
| 00:09:24,478 | 这个的USD价值，这可能是一个 |
| 00:09:27,059 | 我们希望 |
| 00:09:29,340 | 公开的函数，这样其他人可以 |
| 00:09:33,179 | 也使用它 |
| 00:09:34,319 | 所以创建一个函数 |
| 00:09:37,139 | get USD value或者传入一些 |
| 00:09:38,099 | address token |
| 00:09:40,800 | uint amount |
| 00:09:42,119 | 这将是一个public view，返回 |
| 00:09:44,579 | uint256，这就是我们 |
| 00:09:48,059 | 要做一些价格预言机的地方，一些 |
| 00:09:49,619 | 非常熟悉的东西 |
| 00:09:51,898 | 所以我们需要获取 |
| 00:09:55,019 | 代币的价格 |
| 00:09:58,918 | 预言机 |
| 00:10:00,779 | 然后用数量乘以价格 |
| 00:10:02,639 | 所以我们必须再次使用aggregator V3 |
| 00:10:04,918 | interface，那个Chainlink数据 |
| 00:10:06,599 | 预言机，所以import，我知道我们之前用过 |
| 00:10:09,059 | 这个 |
| 00:10:11,398 | aggregator V3 interface |
| 00:10:13,679 | 从 |
| 00:10:15,719 | 看起来GitHub Copilot帮我 |
| 00:10:17,059 | 找到了，@chainlink/contracts等等 |
| 00:10:20,699 | 这意味着我们需要安装 |
| 00:10:22,679 | 它，记住我们可以用更小的那个安装，forge install |
| 00:10:24,840 | smartcontractkit/chainlink |
| 00:10:26,760 | brownie contracts at |
| 00:10:27,840 | 0.6.1 --no-commit像这样 |
| 00:10:29,340 | chainlink brownie contracts |
| 00:10:32,040 | 太棒了，然后我们需要去 |
| 00:10:35,040 | foundry.toml |
| 00:10:38,179 | 添加一些remappings |
| 00:10:41,659 | 所以我们要加一个逗号 |
| 00:10:47,159 | 我们要说@chainlink/ |
| 00:10:52,500 | contracts等于 |
| 00:10:53,938 | lib/chainlink-brownie-contracts |
| 00:10:55,918 | /contracts |
| 00:10:58,019 | 像那样，所以现在我们有了aggregator |
| 00:11:00,359 | V3 interface，向下滚动到底部 |
| 00:11:03,659 | get USD value，我知道我们之前做过 |
| 00:11:06,059 | 这个，我知道这对很多人来说很熟悉 |
| 00:11:10,619 | 但我们要说aggregator |
| 00:11:12,300 | V3 interface price feed等于 |
| 00:11:14,398 | aggregator V3 interface(s下划线price |
| 00:11:16,978 | feeds[token])，所以我们要获取 |
| 00:11:19,500 | 我们想要获取价值的代币的价格预言机 |
| 00:11:22,019 | 现在我们有了 |
| 00:11:23,878 | 这里的价格预言机，我们要做 |
| 00:11:27,000 | 这个，哇，Copilot说得对，我们 |
| 00:11:29,579 | 要通过调用price |
| 00:11:30,540 | feed的latestRoundData来获取价格，这就是 |
| 00:11:33,059 | 我们要做一点 |
| 00:11:34,978 | 数学计算的地方，对吧，假设1 ETH等于1000 |
| 00:11:36,958 | 美元 |
| 00:11:39,000 | 从CL返回的值将是1000 |
| 00:11:42,840 | 乘以 |
| 00:11:44,219 | 1e8，我怎么知道这个？如果我去 |
| 00:11:47,340 | docs.chain.link，去数据预言机 |
| 00:11:48,300 | 我可以向下滚动到 |
| 00:11:50,398 | 价格预言机地址 |
| 00:11:51,599 | 我可以看到如果我显示更多详情 |
| 00:11:57,239 | 对于ETH/USD |
| 00:11:58,760 | USD，它有8位小数 |
| 00:12:02,119 | |
| 00:12:05,159 | |
| 00:12:07,378 | |
| 00:12:09,478 | |
| 00:12:13,079 | |
| 00:12:15,619 | |
