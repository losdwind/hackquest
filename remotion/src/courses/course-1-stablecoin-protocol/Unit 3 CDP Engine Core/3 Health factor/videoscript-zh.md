# 3 Health factor

> 使用LIQUIDATION_THRESHOLD计算health factor和最小抵押率，并处理精度问题。

| 时间戳 | 内容 |
| :--- | :--- |
| 00:00:00,000 | 这就是有时你会看到CEI被 |
| 00:00:02,340 | 违反的地方，当我需要检查某些东西 |
| 00:00:04,199 | 在代币转账发生之后，有时 |
| 00:00:07,199 | 你会看到这个CEI被违反一点点 |
| 00:00:09,659 | 你可以做的是 |
| 00:00:12,659 | 像在之后计算health factor |
| 00:00:16,860 | 然后像模拟它，但很多 |
| 00:00:19,860 | 人选择不这样做，因为 |
| 00:00:21,058 | 这真的很耗gas，所以很多 |
| 00:00:23,520 | 人做的是他们就继续 |
| 00:00:25,199 | 先做代币转账 |
| 00:00:27,840 | 然后检查这个，如果 |
| 00:00:31,558 | 发生这种情况就回滚，这通常是可以的 |
| 00:00:34,138 | 因为如果它是坏的，我们会回滚 |
| 00:00:36,780 | 交易，对吧，所以 |
| 00:00:39,239 | 我们要做的是我们会做这个代币转账 |
| 00:00:41,280 | 然后我们会确保health |
| 00:00:42,479 | factor是可以的，所以你知道如何移动 |
| 00:00:44,760 | 代币，所以我们会说bool |
| 00:00:46,319 | success |
| 00:00:47,280 | 等于IERC20 |
| 00:00:49,739 | tokenCollateral |
| 00:00:51,739 | Address.我们可以直接用transfer |
| 00:00:54,780 | 而不是transferFrom，因为 |
| 00:00:57,000 | transfer是当你从 |
| 00:00:59,039 | 自己转账时，transferFrom是当你 |
| 00:01:00,840 | 从别人那里转账时 |
| 00:01:02,579 | 所以.transfer，我们要 |
| 00:01:05,159 | 发送给msg.sender，我们 |
| 00:01:08,099 | 要发送amountCollateral，然后 |
| 00:01:10,379 | 如果不成功，如果不成功，我们 |
| 00:01:14,039 | 就直接回滚DSCEngine |
| 00:01:16,500 | 我们就做 |
| 00:01:18,799 | TransferFailed像这样，然后我们 |
| 00:01:22,920 | 想确保health factor |
| 00:01:25,199 | 没有被破坏，我们已经写了一个 |
| 00:01:27,360 | 函数来做这个 |
| 00:01:29,579 | 叫做revertIfHealthFactorIsBroken |
| 00:01:31,860 | 所以我们可以直接抓取这个，回到我们的 |
| 00:01:34,979 | redeem，然后做revertIfHealth |
| 00:01:36,899 | FactorIsBroken对于msg. |
| 00:01:39,000 | sender |
| 00:01:40,260 | 好的，很好，就像我说的，我们会 |
| 00:01:42,058 | 很快重构这个，好的，但它 |
| 00:01:44,879 | 看起来这对于赎回collateral实际上非常好 |
| 00:01:46,739 | 现在这个 |
| 00:01:49,979 | revertIfHealthFactorIsBroken对于 |
| 00:01:51,959 | 这个原始的redeemCollateral来说有点麻烦 |
| 00:01:54,058 | 假设我存入了100，然后我mint了 |
| 00:01:55,799 | 价值20的DSC，价值100的ETH |
| 00:01:59,218 | 我mint了价值20的DSC，假设我 |
| 00:02:02,218 | 完成了，我想burn所有的DSC |
| 00:02:05,399 | 我想取出所有的ETH |
| 00:02:08,099 | 如果我试图赎回所有ETH，它会 |
| 00:02:11,218 | 破坏，对吧，它会破坏我的health factor |
| 00:02:13,379 | 我需要先做的是 |
| 00:02:15,360 | 我需要先burn回我的DSC，然后 |
| 00:02:18,420 | 我需要赎回ETH，所以这有点 |
| 00:02:22,679 | 是两个交易的过程 |
| 00:02:25,319 | 有点糟糕，所以让我们把它变成 |
| 00:02:27,718 | 一个交易的过程，所以我们 |
| 00:02:29,760 | 要把赎回collateral |
| 00:02:31,739 | 与burn你的DSC结合起来，这意味着 |
| 00:02:34,079 | 我们需要创建一个burnDSC |
| 00:02:37,500 | 函数，我们也会 |
| 00:02:39,299 | 稍后重构这个 |
| 00:02:40,860 | 但我现在要写它，就好像这是 |
| 00:02:43,379 | 唯一的burnDSC函数 |
| 00:02:45,119 | 所以让我们让人们burn他们的DSC |
| 00:02:48,299 | 这是当他们 |
| 00:02:51,000 | 说嘿我完成了这些代币 |
| 00:02:52,260 | 这会减少，如果我们滚动 |
| 00:02:54,840 | 到顶部，我们有这个mapping |
| 00:02:57,780 | s_DSCMinted，它会减少这个s_DSC |
| 00:03:00,619 | Minted，所以本质上它会减少他们在 |
| 00:03:03,780 | 系统中的债务，所以burnDSC，我们 |
| 00:03:06,360 | 要在这里添加一些修饰符 |
| 00:03:10,679 | 应该大于零 |
| 00:03:12,420 | amount，所以我们想做一个uint256 amount |
| 00:03:16,079 | 他们可以burn任意数量 |
| 00:03:20,340 | 然后我们要做的 |
| 00:03:22,260 | 是我们要说s下划线DSC |
| 00:03:24,479 | minted[msg.sender] |
| 00:03:27,299 | 要减等于amount |
| 00:03:30,780 | 所以我们要移除那个债务 |
| 00:03:33,239 | 移除那个DSC minted，然后我们 |
| 00:03:34,979 | 要做一个小bool |
| 00:03:38,099 | success |
| 00:03:40,379 | 等于i_dsc.transfer |
| 00:03:41,760 | From |
| 00:03:45,360 | msg.sender到address(this)，amount |
| 00:03:48,058 | 我们也可以把这个发送到零 |
| 00:03:52,260 | 地址，但我们现在要把它发送到 |
| 00:03:54,780 | 我们的地址，因为 |
| 00:03:56,218 | 去中心化稳定币ERC20 burnable |
| 00:03:59,638 | 有它自己的burn函数，我们只会 |
| 00:04:03,239 | 直接在代币本身上调用burn函数 |
| 00:04:05,879 | 但首先我们要 |
| 00:04:07,319 | 从他们那里拿走它 |
| 00:04:09,539 | 把它带入我们的合约，然后 |
| 00:04:11,099 | 我们要burn它，所以如果不成功 |
| 00:04:12,599 | 那么我们会回滚DSCEngine |
| 00:04:16,379 | TransferFailed像这样 |
| 00:04:20,819 | 这个条件有点理论上 |
| 00:04:24,058 | 无法到达 |
| 00:04:25,558 | 因为如果这里的转账失败 |
| 00:04:26,699 | 我们会抛出transferFrom |
| 00:04:29,340 | fail错误，但假设这个DSC代币 |
| 00:04:30,780 | 实现错误，很好，我们有点 |
| 00:04:33,840 | 有这个备份，但所以他们要 |
| 00:04:35,579 | 把他们的DSC代币发送到这里 |
| 00:04:37,799 | 他们要调用i_dsc.burn(amount)，现在因为 |
| 00:04:40,079 | 我们在burn DSC，问题是我们需要 |
| 00:04:44,159 | 检查这是否破坏了 |
| 00:04:47,218 | health factor吗？可能不需要 |
| 00:04:50,879 | 因为我们在burn DSC，我们在burn |
| 00:04:54,179 | 债务，burn你的债务 |
| 00:04:55,920 | 移除你的债务不太可能 |
| 00:04:58,440 | 破坏health factor，对吧 |
| 00:05:00,479 | 我们可能永远不需要这个，但我 |
| 00:05:02,940 | 现在只会把这个加在这里 |
| 00:05:05,520 | 作为备份，在gas审计中我们可以 |
| 00:05:08,459 | 弄清楚我们是否真的需要它 |
| 00:05:12,239 | 我不认为 |
| 00:05:14,218 | 这会触发，这就是当我 |
| 00:05:15,539 | 去审计时，当我去找 |
| 00:05:19,979 | 安全专业人士时 |
| 00:05:22,619 | 我可以确保指出这一行 |
| 00:05:24,000 | 说嘿我不认为这一行会 |
| 00:05:25,799 | 触发，我在考虑把它 |
| 00:05:27,179 | 删掉，你怎么看，对吧，在你的注释中 |
| 00:05:29,159 | 指出这些是很好的 |
| 00:05:31,860 | 当你去找专业人士时，谁知道 |
| 00:05:33,058 | 他们可以帮你弄清楚，所以 |
| 00:05:35,159 | 现在我们要把它放在这里 |
| 00:05:37,920 | 虽然我们很可能不 |
| 00:05:38,819 | 需要这个 |
| 00:05:40,500 | 我们很快会重构这个 |
| 00:05:41,760 | 函数的，所以我们有 |
| 00:05:43,138 | 这个burnDSC函数 |
| 00:05:45,420 | 我们要让它public，因为 |
| 00:05:47,280 | 我们要burn DSC和 |
| 00:05:48,959 | 同时赎回collateral |
| 00:05:51,539 | 所以现在我们赎回了collateral |
| 00:05:53,459 | 我们有burnDSC，现在我们可以写这个 |
| 00:05:55,319 | redeemCollateralForDSC，我们 |
| 00:05:57,899 | 发送DSC并同时赎回collateral |
| 00:06:00,420 | |
| 00:06:03,179 | 所以在这里我们要说 |
| 00:06:04,138 | address tokenCollateralAddress |
| 00:06:05,340 | uint256 |
| 00:06:10,619 | amountCollateral |
| 00:06:12,599 | uint256 amountDscToBurn |
| 00:06:15,479 | 我们让这个是external |
| 00:06:19,739 | 然后我们要调用burnDsc |
| 00:06:21,718 | 带上amountDscToBurn |
| 00:06:23,638 | 我们也要调用redeem |
| 00:06:26,099 | Collateral，所以我们要先burn |
| 00:06:28,319 | DSC，然后我们要赎回 |
| 00:06:30,179 | 他们的collateral，带上token |
| 00:06:32,218 | CollateralAddress，amountCollateral |
| 00:06:34,679 | |
| 00:06:38,280 | 哦这是external，让我们把这个改成 |
| 00:06:41,218 | public |
| 00:06:43,199 | 让我们回去 |
| 00:06:44,159 | 然后当然我们应该revert |
| 00:06:45,360 | 如果health factor被破坏，但如果我们 |
| 00:06:47,819 | 看我们的redeemCollateral函数 |
| 00:06:49,679 | 目前已经做了这个，所以我们不 |
| 00:06:51,959 | 需要在这里做，所以我只会 |
| 00:06:53,879 | 把这个注释放在这里，redeemCollateral |
| 00:06:55,799 | 已经检查health factor |
| 00:06:59,699 | 然后我们会添加一点nat |
| 00:07:03,718 | spec，所以@param |
| 00:07:05,399 | 嘣，那甚至不是正确的param |
| 00:07:07,799 | tokenCollateralAddress，要赎回的collateral |
| 00:07:10,079 | 地址，@param amountCollateral |
| 00:07:14,459 | 要赎回的collateral数量，@param |
| 00:07:18,479 | amountDscToBurn，要burn的DSC数量 |
| 00:07:20,940 | 这个函数 |
| 00:07:22,979 | burn DSC并在一个交易中 |
| 00:07:24,920 | 赎回底层 |
| 00:07:30,239 | collateral |
| 00:07:31,979 | |
| 00:07:34,558 | 好的，很好，我们会很快重构这 |
| 00:07:37,138 | 两个函数吗？是的绝对会，但我 |
| 00:07:40,079 | 希望你理解为什么我们要 |
| 00:07:41,218 | 重构它们，所以我们现在要 |
| 00:07:42,899 | 保持它们原样 |
| 00:07:48,479 | 好的，很好，所以这看起来相当不错 |
| 00:07:52,199 | 所以我们这里有很多东西 |
| 00:07:55,440 | 我们有depositCollateralAndMintDsc |
| 00:07:58,020 | 所以人们可以通过 |
| 00:08:00,179 | 存入collateral来mint我们的稳定币 |
