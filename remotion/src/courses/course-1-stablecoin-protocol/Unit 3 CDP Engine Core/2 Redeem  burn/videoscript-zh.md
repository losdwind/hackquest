# 2 赎回和销毁

> 实现redeemCollateralForDsc函数：在赎回collateral之前销毁债务，内部函数复用模式。

| 时间戳 | 内容 |
| :--- | :--- |
| 00:00:00,000 | 我知道Bitcoin USD也有8位 |
| 00:00:02,279 | 小数位，我们可以在这里加一些代码 |
| 00:00:04,379 | 确保我们获取到 |
| 00:00:05,879 | 正确的小数位，但我现在 |
| 00:00:07,618 | 先用8位，现在我们可以做 |
| 00:00:09,899 | 一些数学计算了 |
| 00:00:11,460 | 所以我们需要做price乘以 |
| 00:00:14,578 | amount对吧，这就是我们需要 |
| 00:00:17,519 | 做的吗，price乘以amount，不对，因为 |
| 00:00:20,460 | 这个数字会太大 |
| 00:00:22,078 | 对吧，假设price是一千 |
| 00:00:23,939 | 乘以1E8，现在我们要 |
| 00:00:28,138 | 乘以，假设amount是 |
| 00:00:30,538 | 一千乘以1e18，因为它 |
| 00:00:34,379 | 会是wei，这个数字会 |
| 00:00:36,299 | 非常巨大，对吧，所以首先 |
| 00:00:39,000 | 我们需要把这个一千乘以一个 |
| 00:00:41,879 | 数字来让这个数字匹配 |
| 00:00:44,219 | 那个数字，所以这些需要是相同的精度 |
| 00:00:46,259 | 单位 |
| 00:00:47,279 | 所以我们要 |
| 00:00:49,199 | 先把这个乘以1E10 |
| 00:00:53,098 | 因为我不喜欢魔法数字，我们 |
| 00:00:54,839 | 滚动到顶部 |
| 00:00:56,219 | 创建一个新的状态变量，就在这里 |
| 00:00:58,558 | 我们要做一个uint256 private |
| 00:01:02,759 | constant |
| 00:01:04,638 | additional feed Precision等于1E10 |
| 00:01:09,960 | 像这样，现在它不是魔法 |
| 00:01:12,118 | 数字了 |
| 00:01:12,960 | 所以现在不是这样做，我们要 |
| 00:01:15,299 | 说好的，price，我们要 |
| 00:01:17,519 | 把它包装成uint256，这样 |
| 00:01:19,920 | 所有东西都是uint256，或者说price |
| 00:01:22,799 | 首先需要乘以 |
| 00:01:24,960 | additional feed Precision，这样现在 |
| 00:01:27,179 | 这两个都是uint256，它们 |
| 00:01:29,699 | 都有1E18，但然后我们要 |
| 00:01:33,000 | 把所有这些除以1e18 |
| 00:01:35,819 | 这样这个数字看起来不会 |
| 00:01:37,859 | 特别奇怪，所以我们要 |
| 00:01:39,538 | 把整个东西除以1E18，因为我 |
| 00:01:43,859 | 讨厌 |
| 00:01:44,638 | 像这样的浮动魔法数字，所以 |
| 00:01:46,799 | 我们要滚动回顶部 |
| 00:01:48,239 | 复制粘贴这个，现在只是 |
| 00:01:50,460 | 叫做precision |
| 00:01:52,439 |  |
| 00:01:53,420 | 拿precision |
| 00:01:55,379 | 除以Precision，所以uint256 |
| 00:01:58,199 | price乘以additional feed Precision |
| 00:02:00,420 | 乘以amount除以precision， |
| 00:02:02,879 | 应该没问题了，这时候 |
| 00:02:05,460 | 我的大脑立即想到，好的 |
| 00:02:07,159 | 绝对需要为这个写一些测试 |
| 00:02:09,239 | 所以一旦我们完成了 |
| 00:02:10,920 | 这些，我们绝对要 |
| 00:02:12,420 | 为get USD value写一些测试 |
| 00:02:16,199 | 就在这里 |
| 00:02:17,098 | 所以让我们回到我们刚创建的 |
| 00:02:20,879 | 庞大的函数树 |
| 00:02:22,500 | 这些还没完成，所以让我们回到 |
| 00:02:24,839 | get account collateral value |
| 00:02:27,299 | 这将是total，这个 |
| 00:02:29,638 | total collateral value in USD将是 |
| 00:02:31,439 |  |
| 00:02:32,159 | 获取我们当前处理的token的USD价值 |
| 00:02:35,578 |  |
| 00:02:36,839 | 乘以我们正在处理的amount |
| 00:02:38,819 | total collateral value in USD，实际上 |
| 00:02:41,460 | 让我们把它放在那里，完成，就这样 |
| 00:02:44,879 | 对吧，所以我们只是循环遍历 |
| 00:02:46,859 | token数组中的所有tokens，然后 |
| 00:02:49,739 | 把每一个tokens的USD价值加起来 |
| 00:02:51,899 | 我知道这里不需要 |
| 00:02:53,699 | return，但我还是要在这里加一个 |
| 00:02:54,899 | return，return这个，所以很好 |
| 00:02:58,439 | 现在我们有办法获取 |
| 00:02:59,699 | collateral的USD价值了 |
| 00:03:01,979 | 我们需要这个，在这里上面，哎呀，让我们做 |
| 00:03:04,920 | collateral value |
| 00:03:06,420 | in USD |
| 00:03:09,779 | get collateral value，哎呀，让我们这样做 |
| 00:03:12,960 | 太棒了，所以现在我们的get account |
| 00:03:14,460 | information将返回total |
| 00:03:17,638 | USD minted，total DSC minted，然后 |
| 00:03:20,578 | 所有collateral的total价值 |
| 00:03:22,500 | 在这里，好的，很好 |
| 00:03:27,538 | 现在我们可以再往上滚动 |
| 00:03:29,159 | 我们有这个revert if Health factor is |
| 00:03:31,138 | broken，它还是坏的，因为 |
| 00:03:33,359 | 这个函数什么也不做，但是 |
| 00:03:36,179 | 现在我们可以让它真正做点什么 |
| 00:03:37,979 | 因为我们有这个health Factor |
| 00:03:40,379 | 我们要更新我们的health Factor |
| 00:03:42,239 | 函数 |
| 00:03:43,319 | 因为现在我们有了这两个 |
| 00:03:44,819 | 我们能做的就是 |
| 00:03:48,118 | 获取这两个的比率，所以我们可以 |
| 00:03:50,879 | 说 |
| 00:03:52,078 | collateral value in USD |
| 00:03:54,179 | 除以total USD minted，这就是 |
| 00:03:57,299 | 我们要返回的health |
| 00:03:59,159 | Factor对吧，嗯，不太对，所以假设 |
| 00:04:03,118 | 我们mint了，我们有100 collateral除以 |
| 00:04:06,299 | 100 DSC对吧，这是一比一，如果 |
| 00:04:10,500 | 我们降低，如果我们降低一分钱 |
| 00:04:12,719 | 我们就会under collateralized |
| 00:04:14,339 | 对吧，我们不想 |
| 00:04:16,799 | under collateralized，我们总是想over |
| 00:04:18,420 | collateralized |
| 00:04:20,098 | 因为如果这个低于100，我们的 |
| 00:04:23,939 | 系统就完蛋了，对吧，所以我们想 |
| 00:04:26,879 | 设置阈值为，嘿，如果 |
| 00:04:28,439 | 你低于150 |
| 00:04:30,598 | collateral，你就会被清算，对吧 |
| 00:04:33,058 | 因为我们低于100就已经太 |
| 00:04:35,339 | 晚了 |
| 00:04:36,058 | 所以我们想说，嘿，我们希望你至少 |
| 00:04:37,859 | 达到150。所以我们要创建一个 |
| 00:04:41,638 | liquidation threshold |
| 00:04:43,259 | 我们要在顶部这样做 |
| 00:04:45,538 | 所以我们要说uint256 |
| 00:04:48,659 | private |
| 00:04:50,038 | constant |
| 00:04:51,379 | liquidation threshold等于50。 |
| 00:04:56,098 | 这意味着你需要是150，或者不，这 |
| 00:04:58,920 | 意味着你需要是200%的over |
| 00:05:02,239 | collateralized，我想 |
| 00:05:04,500 | 可能是150%，但我们会在测试中 |
| 00:05:06,719 | 找出答案 |
| 00:05:07,618 | 所以现在如果我们回到 |
| 00:05:09,179 | 这里 |
| 00:05:09,839 | 要获取我们的health Factor，我们不只是 |
| 00:05:11,578 | 把这两个相除，即使这样 |
| 00:05:13,859 | 也不太行，因为如果我们有 |
| 00:05:15,118 | 150除以100，150除以100等于 |
| 00:05:18,598 | 1.5，小数在Solidity中不起作用 |
| 00:05:21,179 | 所以它只会是1 |
| 00:05:22,739 | 我猜那样也能work，但我们想，我们 |
| 00:05:24,960 | 想准确知道health |
| 00:05:26,339 | factor是什么，对吧，带precision，所以首先 |
| 00:05:28,979 |  |
| 00:05:29,699 | 让我们不只是这样做，让我们 |
| 00:05:32,339 | 说uint256 collateral adjusted |
| 00:05:37,018 | 或threshold等于collateral value |
| 00:05:41,279 | in USD |
| 00:05:42,538 | 乘以 |
| 00:05:43,920 | liquidation threshold，然后我们应该 |
| 00:05:46,319 | 除以100对吧，因为 |
| 00:05:48,058 | liquidation threshold正在乘以， |
| 00:05:50,399 | 它让我们的数字变大了很多 |
| 00:05:52,558 | 所以我们应该除以100，因为我不 |
| 00:05:54,659 | 喜欢 |
| 00:05:55,439 | 浮点数，所以我们要做uint256 |
| 00:05:58,018 | private constant |
| 00:06:00,739 | liquidation |
| 00:06:02,659 | Precision等于100，所以我们要回到 |
| 00:06:06,479 | 下面 |
| 00:06:07,379 | 除以liquidation precision |
| 00:06:09,538 | 所以现在我们有这个collateral amount |
| 00:06:11,118 | 针对这个threshold调整过的，对吧 |
| 00:06:14,038 | 所以现在你可以把它想成 |
| 00:06:16,078 | 不是说我们有150个 |
| 00:06:19,558 | 除以100个DSC对吧，这会 |
| 00:06:23,638 | 是1.5，但现在它们也需要乘以 |
| 00:06:27,779 | 50 |
| 00:06:29,518 | 但现在这个collateral value |
| 00:06:31,439 | 本质上被乘以五分之一了 |
| 00:06:33,538 | 对吧，让我们算算这里的数学，对吧 |
| 00:06:36,118 | 如果我们有 |
| 00:06:37,439 | 比如一千美元的eth，我们只是 |
| 00:06:40,618 | 乘以50，这让我们得到50000 |
| 00:06:44,819 | 但然后我们除以100 |
| 00:06:46,979 | 等于500。所以如果我们有 |
| 00:06:50,219 | 一千美元的eth乘以50等于 |
| 00:06:53,339 | 这个除以100是500。和 |
| 00:06:55,799 | 下面这个例子一样，如果我们有 |
| 00:06:57,899 | 150美元的eth，我们说150乘以 |
| 00:07:01,979 | 50等于 |
| 00:07:04,159 | 7500除以100等于75，然后 |
| 00:07:09,420 | 如果我们做75除以100，那会 |
| 00:07:12,299 | 绝对小于1，对吧，所以 |
| 00:07:15,420 | 我们基本上是在说，用这个50 |
| 00:07:17,518 | threshold，50除以100本质上是1 |
| 00:07:20,879 | 除以2。我们在说你需要有 |
| 00:07:22,679 | 两倍的collateral在这里，所以是的，所以 |
| 00:07:25,199 | 现在我大声说出来了，这个50 |
| 00:07:28,018 | liquidation threshold意味着我们需要 |
| 00:07:30,179 | 是200% over collateralized对吧，我们需要 |
| 00:07:32,939 | 有两倍于minted DSC的collateral |
| 00:07:34,679 | ，不管怎样，做了一堆 |
| 00:07:39,479 | 数学计算，希望这有意义，如果 |
| 00:07:42,118 | 没有，一定要和你的AI一起工作，确保 |
| 00:07:44,460 | 这有意义，或者在讨论中提问 |
| 00:07:46,558 | 对吧，我知道一些 |
| 00:07:48,479 | 数学可能会有点棘手 |
| 00:07:49,679 | 这里 |
| 00:07:50,279 | 所以collateral adjusted for threshold |
| 00:07:52,558 | 现在我们可以return |
| 00:07:54,779 | collateral adjusted，哎呀，这个 |
| 00:07:57,479 | collateral adjusted for threshold |
| 00:07:59,578 | 乘以 |
| 00:08:00,899 | precision |
| 00:08:02,219 | 除以那个total DSC minted，现在 |
| 00:08:05,939 | 这会给我们真实的Health factor |
| 00:08:08,219 | 如果这个小于1，你现在就会被 |
| 00:08:10,618 | 清算 |
| 00:08:12,479 | 这是一个例子 |
| 00:08:14,460 | 对吧，让我们看看另一个例子 |
| 00:08:15,960 | 我想这是两个例子 |
| 00:08:18,179 | 所以假设他们有一千 |
| 00:08:20,279 | 美元的eth和100 DSC对吧 |
| 00:08:25,199 | 所以让我们算算数学，1000乘以50 |
| 00:08:29,518 | 等于五万一二三除以 |
| 00:08:32,159 | 100等于500 |
| 00:08:35,879 | 500除以100 |
| 00:08:38,098 | 这绝对大于1 |
| 00:08:39,779 | 对吧，500除以100是5。所以这个 |
| 00:08:42,779 | 存入了一千美元eth |
| 00:08:44,699 | 并minted了100 DSC的人会有 |
| 00:08:47,098 | 一个health factor为500。很好，所以现在 |
| 00:08:51,179 | 我们有了health Factor，我们实际上可以 |
| 00:08:53,038 | 最终做这个revert if Health factor |
| 00:08:55,199 | is broken函数，或者我们可以说我们甚至可以把这个 |
| 00:08:58,439 | 放在 |
| 00:08:59,939 | 这个上面，作为一种伪net |
| 00:09:01,739 | spec，我们可以说 |
| 00:09:03,538 | uint256 Health Factor等于 |
| 00:09:07,199 | underscore health |
| 00:09:08,638 | factor of the user，我们说if |
| 00:09:12,719 | user |
| 00:09:13,618 | 抱歉，实际上让我们做user Health |
| 00:09:16,199 | factor，如果user Health Factor |
| 00:09:19,379 | 小于某个Min Health factor |
| 00:09:22,799 | 它将是1 Health fact，所以 |
| 00:09:24,899 | 让我们创建这个，让我们到 |
| 00:09:26,159 | 顶部，因为我们讨厌浮点 |
| 00:09:28,138 | 数字 |
| 00:09:29,159 | uint256 private constant Min Health |
| 00:09:32,819 | Factor等于1，如果user Health |
| 00:09:35,219 | factor小于Min Health |
| 00:09:36,779 | Factor，那么我们要revert |
| 00:09:38,819 | 我不太喜欢这个，来做DSC |
| 00:09:42,118 | engine |
| 00:09:43,558 | underscore underscore |
| 00:09:45,239 | breaks |
| 00:09:46,500 | Health Factor，我要传入这个 |
| 00:09:49,859 | 我们break的health factor，完成 |
| 00:09:52,078 | 新error，滚动到顶部，error engine |
| 00:09:55,859 | breaks Health Factor，uint256 Health |
| 00:09:58,799 | Factor |
| 00:10:02,098 | 看起来我们这里还有一些红色 |
| 00:10:03,359 | 我忘了什么，好的revert if |
| 00:10:04,920 | Health factor is broken underscore像 |
| 00:10:06,598 | 这样，完成，现在看起来没有 |
| 00:10:08,939 | 红色了，让我们确保Forge build |
| 00:10:12,899 | 成功，很好 |
| 00:10:18,598 | 好的，我们在哪里，mint DSC，好的 |
| 00:10:22,138 | mint DSC，所以我们添加了一些更多的DSC minted |
| 00:10:26,098 | 如果添加这个DSC breaks health |
| 00:10:29,879 | Factor，因为 |
| 00:10:31,500 | breaks health Factor，我们应该 |
| 00:10:32,879 | revert，我们不应该让任何人mint |
| 00:10:35,038 | DSC，如果他们会导致自己 |
| 00:10:37,859 | 被清算，我的意思是我们可以 |
| 00:10:40,199 | 让他们这样做，但像，让我们 |
| 00:10:41,879 | 不要这样做，因为那不是一个很好的用户 |
| 00:10:44,339 | 体验，现在我们想做的是 |
| 00:10:47,279 | 实际mint DSC，所以这就是 |
| 00:10:50,399 | 地方 |
| 00:10:51,239 | DSC有这个只有owner的mint函数 |
| 00:10:54,179 | 这个的owner将 |
| 00:10:56,399 | 是DSC engine，现在我们可以 |
| 00:10:58,859 | 说，如果我们看这个mint函数 |
| 00:11:01,319 | 它返回一个Boolean，所以我们说bool |
| 00:11:05,219 | minted等于i underscore DSC dot mint |
| 00:11:10,259 | 它的参数是什么 |
| 00:11:11,819 | address to和amount |
| 00:11:14,159 | 所以address to将是 |
| 00:11:15,500 | message.sender，amount将是 |
| 00:11:18,118 | amount DSC to Mint，然后我们说if |
| 00:11:21,899 | not minted |
| 00:11:23,819 | 好吧，让我们只是说revert DSC engine |
| 00:11:27,118 | underscore underscore mint failed， |
| 00:11:30,118 | 这是一个新error，滚动到 |
| 00:11:32,518 | 顶部，error DSC mint failed |
| 00:11:36,538 | 很好 |
| 00:11:44,460 | 所以现在我们有一个mint函数，我们 |
| 00:11:47,399 | 有一个deposit函数，所以我们可以 |
| 00:11:49,018 | deposit collateral，我们可以mint DSC，但是 |
| 00:11:52,199 | 此外，我们可以获取account |
| 00:11:53,638 | information，我们可以计算某人的 |
| 00:11:55,618 | Health Factor，我们可以计算USD |
| 00:11:58,078 | 这些不同tokens的价值 |
| 00:12:00,118 | 所以这时候我想，哎呀，我不 |
| 00:12:03,000 | 知道我在做的是否 |
| 00:12:05,038 | 有意义，我想确保我在这里写一些 |
| 00:12:06,538 | 测试，所以这时候我们可以 |
| 00:12:09,779 | 创建一个新文件夹unit tests |
| 00:12:12,479 | 如果你想的话，你可以跳过 |
| 00:12:14,939 | 写脚本，只是在你的unit tests中部署 |
| 00:12:17,038 | 然后做一些integration tests，但我只是 |
| 00:12:19,138 | 要让我的unit tests也是我的 |
| 00:12:22,138 | integration test |
| 00:12:23,819 | 所以让我们开始，让我们写一个脚本 |
| 00:12:25,979 | deploy |
| 00:12:27,179 | DSC |
| 00:12:28,739 | dot s dot Sol，你已经知道 |
| 00:12:32,098 | 流程了 |
| 00:12:33,719 | spdx |
| 00:12:35,460 | license I |
| 00:12:37,739 | 我甚至可以放大一点，identifier |
| 00:12:39,960 | MIT |
| 00:12:41,038 | contract deploy DSC is script |
| 00:12:45,899 | import script |
| 00:12:48,058 | from Forge STD |
| 00:12:51,859 | script.sol像这样，pragma |
| 00:12:55,319 | solidity |
| 00:12:56,719 | 0.8.18，好在这里我们要 |
| 00:13:00,420 | 有我们的function run external，我们 |
| 00:13:03,598 | 做过一百次了，external |
| 00:13:06,118 | null，这将returns |
| 00:13:09,058 | 几个东西，它将 |
| 00:13:10,799 | 返回DS |
| 00:13:12,799 | decentralized stable coin和DSC |
| 00:13:16,979 | engine，它将return |
| 00:13:18,659 | 别的东西，但我还不打算把 |
| 00:13:19,859 | 它放进去，所以要做到这个，我们要 |
| 00:13:21,839 | import |
| 00:13:23,578 | decentralized stablecoin |
| 00:13:26,219 | from dot slash SRC slash |
| 00:13:30,259 | decentralizedstablecoin.sol，我要 |
| 00:13:32,339 | 关闭并重新打开我的vs code，它现在 |
| 00:13:35,038 | 表现得很奇怪，好了，都 |
| 00:13:37,618 | 修复了，所以这两个，我们要 |
| 00:13:40,500 | 做什么呢，我们要做 |
| 00:13:41,939 | vm.start |
| 00:13:43,618 | broadcast像这样，vm.stop |
| 00:13:47,038 | broadcast |
| 00:13:48,479 | 像这样，哦，我们需要DSC engine |
| 00:13:51,199 | import DSC engine from slash SRC slash |
| 00:13:56,819 | DSC engine.sol |
| 00:13:58,618 | 在这里 |
| 00:14:00,058 | 我们要部署这两个，所以 |
| 00:14:02,399 | 我们说 |
| 00:14:03,479 | decentralized stablecoin DSC等于new |
| 00:14:07,159 | decentralized stablecoin，我们的 |
| 00:14:09,598 | decentralized stablecoin有任何 |
| 00:14:11,038 | 参数吗，它没有，我们也要 |
| 00:14:14,460 | 部署我们的dsce |
| 00:14:17,399 | 或DSC engine |
| 00:14:19,699 | 等于new |
| 00:14:21,659 | DSC engine，这需要一堆 |
| 00:14:25,078 | 东西对吧，这将需要去到 |
| 00:14:28,799 | Constructor，token addresses，price |
| 00:14:31,618 | feed addresses，如果我们toggle哎呀toggle |
| 00:14:34,859 | word wrap，addresses，price feed |
| 00:14:36,960 | addresses和DSC address，所以我们有 |
| 00:14:39,479 | DSC address，完成，它将是 |
| 00:14:41,279 | 这个 |
| 00:14:42,118 | 我们从哪里得到price feed addresses |
| 00:14:43,859 | 你猜对了，我们要做一个 |
| 00:14:45,960 | helper config，所以这个DSC engine |
| 00:14:48,420 | 需要什么 |
| 00:14:49,558 | constructor需要一个token addresses数组 |
| 00:14:52,799 | 一个price feeds数组，然后DSC |
| 00:14:55,259 | address，所以 |
| 00:14:57,179 | 我们要从哪里得到那些 |
| 00:14:58,259 | addresses，你猜对了，一个helper |
| 00:15:00,299 | config，所以new file |
| 00:15:03,659 | helper config.s dot Sol |
| 00:15:06,859 | spdx license |
| 00:15:09,960 | identifier MIT，pragma solidity 0.8.18 |
| 00:15:14,759 | contract helper |
| 00:15:17,219 | config is script |
| 00:15:19,799 | import script |
| 00:15:22,500 | from |
| 00:15:25,339 | origin，现在让我们在sepolia |
| 00:15:29,038 | Chain上做这个，所以我们要 |
| 00:15:31,679 | struct |
| 00:15:33,000 | network config，我们这里需要什么 |
| 00:15:36,299 | 我们需要一个，嗯，我们需要weth |
| 00:15:40,379 | 和wrapped Bitcoin，那些price feed |
| 00:15:43,259 | addresses和那些DSC addresses |
| 00:15:44,939 | address |
| 00:15:46,319 | weth USD price feed |
| 00:15:49,979 | address wrapped Bitcoin USD price feed |
| 00:15:54,078 | 再说一次，weth是 |
| 00:15:58,439 | ethereum的erc20版本，我在sepolia上有一个example web token |
| 00:16:01,979 | 合约，如果你看 |
| 00:16:04,199 | 它，就在这里，我们去write contract |
| 00:16:06,359 | 它有这个deposit函数，你 |
| 00:16:08,699 | 存入eth，它会返回给你一个 |
| 00:16:11,819 | erc20版本的eth到你的metamask |
| 00:16:13,979 | 叫做weth，然后当你用完 |
| 00:16:16,739 | 它，你只需提取你的eth |
| 00:16:19,379 | burn你的weth，wrapped Bitcoin是类似的 |
| 00:16:21,899 | 但是是用 |
| 00:16:23,699 | Bitcoin，区别是因为Bitcoin |
| 00:16:25,859 | 不是起源于这个区块链 |
| 00:16:27,299 | bridge它过来有一些风险 |
| 00:16:30,359 | 但我不打算深入那个，那是 |
| 00:16:32,339 | 你要查找的东西，所以我们还 |
| 00:16:34,259 | 要需要 |
| 00:16:35,819 | weth token本身的address，我们要需要 |
| 00:16:37,799 | wrapped Bitcoin本身的address |
| 00:16:40,219 | 我们要需要一个uint256 deploy |
| 00:16:43,819 | deployer key，就像我们在 |
| 00:16:46,739 | 之前的课程中做的那样 |
| 00:16:49,078 | 我们要有Network config public |
| 00:16:52,679 | Active network config，然后我们 |
| 00:16:56,578 | 要有Constructor |
| 00:17:00,058 | 像这里 |
| 00:17:01,319 | 我们要有一个function get sepolia |
| 00:17:04,979 | eth config |
| 00:17:07,078 | public view returns |
| 00:17:09,839 | Network config memory |
| 00:17:13,018 | 这个，然后我们要return |
| 00:17:16,138 | Network config，我们要有 |
| 00:17:20,479 | USD price feed，让我们去 |
| 00:17:24,018 | docs.chain.link，让我们去sepolia，所以 |
| 00:17:28,138 | sepolia，哪里是eth BTC，eth抱歉 |
| 00:17:32,279 | ethusd，就在这里，复制那个，粘贴demo |
| 00:17:35,879 | 我们要需要 |
| 00:17:37,939 | Bitcoin USD price feed在sepolia |
| 00:17:40,500 | bitcoin USD就在这里 |
| 00:17:42,839 | 有了那个，我们需要weth合约 |
| 00:17:45,538 | address，我这里有，这是一个 |
| 00:17:48,659 | 我部署的 |
| 00:17:51,420 | 这里，我们要需要wrapped Bitcoin |
| 00:17:54,239 | 如果你在找所有这些，你 |
| 00:17:56,159 | 想从 |
| 00:17:58,379 | GitHub repo复制它们，你可以 |
| 00:18:00,118 | 去SRC |
| 00:18:01,739 | 你可以去script，helper config， |
| 00:18:04,739 | 它们都在这里，如果你想 |
| 00:18:05,879 | 复制粘贴，但 |
| 00:18:08,098 | 还有wrap Bitcoin，我猜是这个 |
| 00:18:11,699 | address |
| 00:18:12,719 | 但我有一个不同的，好吧，whatever |
| 00:18:14,279 | 我们要用这个，如果它 |
| 00:18:15,779 | 不work那没关系，我们要用 |
| 00:18:17,879 | 这个，当然deployer key |
| 00:18:21,078 | vm.env uint |
| 00:18:23,399 | private key |
| 00:18:25,078 | 像这样，好的，然后我们要做 |
| 00:18:28,379 | function get or create anvil |
| 00:18:33,319 | config，public returns Network config |
| 00:18:39,659 | memory |
| 00:18:41,339 | 我们要做一些mock部署 |
| 00:18:43,038 | 在这里，但我们要 |
| 00:18:45,960 | 说if |
| 00:18:47,759 | Active network config dot weth USD price |
| 00:18:51,659 | feed不等于zero address |
| 00:18:53,759 | 那么我们已经设置它了，return active |
| 00:18:57,479 | network eth config，我们要做 |
| 00:18:59,699 | 一些broadcasting，所以我们要需要几个 |
| 00:19:02,098 | 几个mocks在这里 |
| 00:19:04,500 | 我们要需要一些mock price feeds |
| 00:19:06,839 | 和一些mock erc20 tokens，所以 |
| 00:19:10,920 | 我们要需要一个mock V3 aggregator |
| 00:19:13,920 | 我们要去test，new folder |
| 00:19:17,518 | mocks，我要从这个repo复制粘贴一个mock |
| 00:19:20,759 | 如果你也想复制粘贴 |
| 00:19:22,920 | 去做吧 |
| 00:19:24,538 | test |
| 00:19:25,979 | mocks |
| 00:19:28,078 | mock V3 aggregator |
| 00:19:30,899 | 复制这个 |
| 00:19:35,219 | new file mock V3 aggregator |
| 00:19:39,439 | .sol，很好，import那个，Imports mock V3 |
| 00:19:45,899 | aggregator |
| 00:19:48,299 | from dot dot slash |
| 00:19:50,819 | test slash mocks slash mock V3 |
| 00:19:53,879 | aggregator.sol，所以我们有那个，我们还 |
| 00:19:56,279 | 要需要一些mock erc20s，我们可以 |
| 00:19:58,859 | 直接从open |
| 00:20:00,839 | Zeppelin获取那些，所以如果你做import erc20 |
| 00:20:04,399 | mock from at open Zeppelin slash contracts |
| 00:20:09,239 | slash mocks slash erc20 mock，就这样 |
| 00:20:13,739 | 如果我们command click进这个或你 |
| 00:20:16,199 | 打开它，你可以看到有一整 |
| 00:20:18,000 | 堆东西在这里，比如我们可以mint |
| 00:20:19,379 | 尽可能多，burn尽可能多，做transfers等等，我们做几乎 |
| 00:20:23,038 | 任何我们想做的，这就是为什么 |
| 00:20:24,779 | 它是一个mock token，适合测试 |
| 00:20:26,939 | 所以在这里，vm.start broadcast，我们要 |
| 00:20:31,319 | 创建一个mock V3 aggregator eth USD |
| 00:20:35,279 | price feed等于new mock V3 aggregator |
| 00:20:39,479 | 这个需要什么 |
| 00:20:42,179 | Constructor，需要decimals然后 |
| 00:20:45,299 | 一个initial answer |
| 00:20:46,979 | 所以我们要滚动到这里，我们 |
| 00:20:50,578 | 要说uint256或抱歉uint |
| 00:20:53,098 | 8 |
| 00:20:54,359 | public constant |
| 00:20:56,719 | decimals |
| 00:20:58,578 | decimals等于8，我们说 |
| 00:21:01,439 | uint或不是uint，int256 public |
| 00:21:06,618 | constant eth USD price |
| 00:21:11,219 | 等于 |
| 00:21:12,479 | 2000 E8，然后我们要做 |
| 00:21:16,319 | 同样的事情，但不是eth，它是 |
| 00:21:18,960 | BTC，我们让这个1000 |
| 00:21:22,739 | E8，eth USD，滚动下来，好的，new |
| 00:21:26,998 | mock，它需要什么，control click，uint |
| 00:21:30,420 | 8 decimals，initial answer |
| 00:21:32,460 | control minus回去 |
| 00:21:35,179 | decimals，然后initial answer |
| 00:21:38,118 | 那些，好的，哦，让我们做vm dot stop |
| 00:21:41,819 | broadcast，现在我们要做erc20 mock |
| 00:21:45,920 | weth mock等于 |
| 00:21:48,719 | new erc20 mock，这个需要什么 |
| 00:21:53,399 | name，symbol，initial account，initial |
| 00:21:55,859 | balance，好的，说weth，weth |
| 00:22:00,498 | message.sender |
| 00:22:02,899 | 1000 e8，你可能想做更多 |
| 00:22:06,420 | 我们可能不想有这些 |
| 00:22:07,739 | 浮点数在这里，但是的，它只是 |
| 00:22:09,899 | 一个mock，不是大问题，我想 |
| 00:22:11,159 | 现在我们要复制粘贴所有这个 |
| 00:22:13,618 | 给BTC |
| 00:22:16,679 | BTC |
| 00:22:18,719 | 我们要说BTC |
| 00:22:21,420 | 它将是 |
| 00:22:23,159 | wrapped BTC |
| 00:22:25,439 | wrapped BTC，wrapped BTC像那样，stop |
| 00:22:30,719 | broadcast，然后return |
| 00:22:33,659 | Network config，weth USD price feed将 |
| 00:22:37,859 | 是address，哦谢谢Copilot |
| 00:22:42,299 | 谢谢github copilot，谢谢github |
| 00:22:44,638 | copilot，谢谢github copilot，这 |
| 00:22:48,479 | 实际上将是default |
| 00:22:49,739 | Anvil key，如果你想的话，你可以 |
| 00:22:52,799 | 回到这里，从 |
| 00:22:56,339 | 这里复制粘贴它，或者你知道你只是 |
| 00:22:58,078 | 运行anvil |
| 00:22:59,219 | 滚动上去，完成，private key就在这里 |
| 00:23:02,638 | 取消那个，我们说uint256 |
| 00:23:05,339 | public抱歉，int256 public default |
| 00:23:10,819 | Anvil key等于 |
| 00:23:13,739 | 粘贴那个，我们说我们只是 |
| 00:23:17,638 | 使用default anvil key，如果你 |
| 00:23:19,679 | 用anvil工作，好的，很好，所以现在 |
| 00:23:22,618 | 我们有get or create anvil，是的，这是 |
| 00:23:25,920 | sepolia，让我们更新我们的Constructor |
| 00:23:29,159 | 所以我们说if |
| 00:23:31,159 | block.chain ID等于1 1 1 |
| 00:23:34,638 | 5 5 1 1 1 1那么 |
| 00:23:38,399 | Active network config等于get |
| 00:23:42,659 | sepolia eth config |
| 00:23:45,779 | else |
| 00:23:47,098 | 做Active network config等于get or |
| 00:23:51,118 | create anvil config，很好，所以 |
| 00:23:54,479 | 我们有一个小helper |
| 00:23:55,618 | config在这里，一个小分号在这里 |
| 00:23:58,859 | 这看起来很好，这里有什么问题 |
| 00:24:00,420 | 抱歉这是一个uint256。好的很好，所以 |
| 00:24:05,518 | 现在我们有了helper config，我们可以 |
| 00:24:07,018 | 最终回到我们的deploy DSC，让我们 |
| 00:24:09,598 | import那个进来，import helper config |
| 00:24:12,659 | from |
| 00:24:14,098 | helper config，就在顶部，我们说 |
| 00:24:16,920 | helper config config等于new helper |
| 00:24:21,779 | config，从这个config我们要 |
| 00:24:24,420 | 获取 |
| 00:24:25,859 | 所有这个weth，Bitcoin，wrapped coin |
| 00:24:29,939 | deployer key等等，所以我要说 |
| 00:24:32,339 | address weth USD price feed，哦我甚至 |
| 00:24:35,879 | 可以只按Tab，看起来它 |
| 00:24:38,279 | 有大部分了，是的，让我们用deployer |
| 00:24:41,159 | Bitcoin，weth，wrapped coin，deployer key |
| 00:24:43,679 | 等于config.active network config |
| 00:24:47,279 | 很好，对我来说看起来不错，我要toggle |
| 00:24:49,498 | word wrap，这样它就会换行，好的 |
| 00:24:52,018 | 很好，我们有所有那些了 |
| 00:24:53,879 | 现在我们的DSC engine需要一个 |
| 00:24:56,759 | token addresses数组，一个price feeds数组 |
| 00:24:58,799 | 所以我们可以说 |
| 00:25:00,479 | 就在顶部，让我们做那些 |
| 00:25:01,920 | 数组，我们说address |
| 00:25:03,779 | array |
| 00:25:04,979 | public token addresses |
| 00:25:08,518 | address array public price feed |
| 00:25:12,920 | addresses，我们说token addresses |
| 00:25:16,859 | 等于weth和wrapped BTC |
| 00:25:20,819 | price |
| 00:25:22,319 | feed addresses等于weth USD price |
| 00:25:25,979 | feed address，wrapped Bitcoin USD price feed |
| 00:25:28,679 | 好的很好，我想那就是一切了 |
| 00:25:30,960 | 对吧，是的，所以现在我们可以回到这 |
| 00:25:33,960 | 行，现在 |
| 00:25:34,979 | DSC engine，engine，new DSC engine |
| 00:25:37,339 | 它需要token addresses |
| 00:25:41,699 | price feed addresses和DSC，好的 |
| 00:25:46,439 | 很好，然后最后一些东西我们 |
