# 1 架构

> 设置项目结构并定义架构：DSC 代币 + DSCEngine 分离。

| 时间戳 | 内容 |
| :--- | :--- |
| 00:00:00,000 | 时间 |
| 00:00:04,260 | 好的，我们现在已经学到了很多 |
| 00:00:06,660 | 关于 DeFi 的知识，希望我激起了你的 |
| 00:00:09,120 | 好奇心，还有更多东西 |
| 00:00:11,340 | 需要学习，但现在我们要 |
| 00:00:13,199 | 开始创建我们自己的稳定币 |
| 00:00:16,320 | 所以，你可以跟着 |
| 00:00:18,539 | 我们将要讲解的所有代码 |
| 00:00:20,459 | 在这个 Foundry DeFi |
| 00:00:22,500 | stablecoin f23 课程部分 |
| 00:00:24,600 | 就像我说的，我计划让 |
| 00:00:26,699 | 这个代码真正得到审计，所以如果 |
| 00:00:29,640 | 你有你的 GitHub repo，一定要 |
| 00:00:31,199 | 关注这个 repo 并查看更新 |
| 00:00:33,000 | 因为我会发布审计 |
| 00:00:34,620 | 报告在这里，我有几个 |
| 00:00:36,480 | 关于什么是智能合约 |
| 00:00:37,919 | 审计以及为什么它们如此重要的视频 |
| 00:00:39,720 | 我会在 |
| 00:00:41,459 | 与这门课程相关的 GitHub repo 中留下几个链接 |
| 00:00:42,720 | 对于那些想走 |
| 00:00:44,760 | 安全路线的人，一定要 |
| 00:00:46,320 | 观看这个视频，但好的，我们 |
| 00:00:48,780 | 终于在我们的 GitHub repo 中了，让我们构建 |
| 00:00:52,559 | 这个稳定币，mkdir Foundry DeFi |
| 00:00:57,179 | stablecoin f23，让我们用 |
| 00:01:01,260 | code 打开它，或者你知道流程，file open |
| 00:01:03,419 | folder，我们将在这节课中走得稍微 |
| 00:01:05,519 | 快一点，因为我们正在做的很多事情 |
| 00:01:07,620 |  |
| 00:01:08,579 | 只是在巩固 |
| 00:01:10,019 | 你已经知道的信息，我们 |
| 00:01:12,179 | 有一些新东西要讲 |
| 00:01:13,620 | 比如无状态模糊测试，我们将 |
| 00:01:15,780 | 稍后讨论，但很多 |
| 00:01:17,760 | 编码方面的东西你已经知道了 |
| 00:01:20,459 | 好的，我们在我们的文件夹中，初始化 |
| 00:01:24,179 | clear |
| 00:01:25,500 | 让我们在这里制作一个小 README |
| 00:01:28,199 | 并谈论我们 |
| 00:01:30,179 | 协议的设计 |
| 00:01:31,140 | 所以我们要制作一个稳定币，但 |
| 00:01:34,140 | 如果你看过那个稳定币视频，我们要 |
| 00:01:35,939 | 制作一个稳定币，它是 |
| 00:01:38,220 | 锚定的，所以当我们谈论 |
| 00:01:41,160 | 相对稳定性时 |
| 00:01:42,900 | 要锚定或挂钩到美元 |
| 00:01:46,380 |  |
| 00:01:47,340 | 所以这意味着我们要 |
| 00:01:48,720 | 在这里放一些代码来确保我们的 |
| 00:01:51,840 | 稳定币总是价值一美元 |
| 00:01:54,659 | 第二点，稳定性 |
| 00:01:57,360 | 稳定性机制，或者我们做 |
| 00:02:00,000 | minting 的方式将是 |
| 00:02:02,720 | 算法化的，这意味着这将 |
| 00:02:05,159 | 是一个去中心化的稳定币 |
| 00:02:07,079 | 不会有任何中心化 |
| 00:02:08,640 | 实体来 mint 或 burn 或 |
| 00:02:11,939 | 维持价格，这将是 |
| 00:02:13,800 | 100% 链上和算法化的 |
| 00:02:16,980 | 这理想地是我们对 |
| 00:02:20,699 | 稳定币未来的期望，没有 |
| 00:02:22,320 | 控制实体控制我们的 |
| 00:02:24,000 | 稳定币，所以这很好，一个更好的 |
| 00:02:26,100 | web3 稳定币可能是一个 |
| 00:02:28,199 | 锚定或挂钩的，它可能是 |
| 00:02:29,760 | 浮动的 |
| 00:02:31,079 | 但那是一个更难的机制 |
| 00:02:33,419 | 所以我们暂时采用 |
| 00:02:34,860 | 锚定挂钩的方式，然后 |
| 00:02:36,959 | 最后 collateral 类型将 |
| 00:02:40,320 | 是，你猜对了，外生的 |
| 00:02:43,140 | 它将是加密 collateral |
| 00:02:44,820 | 我们将使用加密货币作为 |
| 00:02:46,620 | 这个货币的 collateral，我们将 |
| 00:02:49,320 | 使用 |
| 00:02:50,280 | Ethereum 和 Bitcoin 作为我们系统的 collateral |
| 00:02:52,860 | 所以有了这个 |
| 00:02:56,159 | 架构，我们要记住 |
| 00:02:58,260 | 好的，我们实际上如何 |
| 00:03:00,360 | 确保这总是锚定到 |
| 00:03:04,019 | 一美元？我们可以做到这一点的一种方法是 |
| 00:03:05,699 | 使用 Chainlink price feed |
| 00:03:07,980 | 所以通过 Chainlink price feed 我们获取 |
| 00:03:10,019 | price feed |
| 00:03:11,340 | 并且我们设置一个函数来交换 ETH |
| 00:03:15,959 | 和 Bitcoin 或者它们的美元 |
| 00:03:19,320 | 等值，这样如果在 |
| 00:03:22,439 | 我们的合约中我们有这个交换设置 |
| 00:03:24,659 | 这个稳定币的价格应该 |
| 00:03:27,419 | 理论上总是在一美元左右 |
| 00:03:30,120 | 要使稳定性机制 |
| 00:03:31,679 | 算法化，我们将说人们 |
| 00:03:34,380 | 只能用足够的 collateral mint 稳定币 |
| 00:03:38,820 |  |
| 00:03:42,419 | 并且这将直接编码到我们的协议中，并且 |
| 00:03:44,519 | collateral 类型是外生的 |
| 00:03:46,380 | 当然，我们只允许这些 |
| 00:03:48,000 | 两种类型的加密货币被 |
| 00:03:49,860 | 存入，具体来说我们将 |
| 00:03:51,900 | 使用 wrapped ETH 和 wrapped Bitcoin，所以 |
| 00:03:54,419 | ETH 的 ERC20 版本和 |
| 00:03:56,579 | Bitcoin 的 ERC20 版本 |
| 00:03:58,140 | 有些人可能会说这个 wrapped |
| 00:04:00,720 | Bitcoin 有点中心化 |
| 00:04:02,640 | 取决于谁在将 |
| 00:04:04,679 | Bitcoin 引入以太坊，但那是另一个 |
| 00:04:06,720 | 话题 |
| 00:04:07,919 | 所以超额抵押的稳定币，用 |
| 00:04:10,620 | WETH 和 Bitcoin 作为 collateral |
| 00:04:13,140 | 让我们开始吧 |
| 00:04:15,720 | 所以我们要做的第一件事是 |
| 00:04:17,579 | 我们要，好吧，我们要摆脱 |
| 00:04:18,840 | 所有这些，再见再见再见 |
| 00:04:21,539 | 删除 |
| 00:04:23,039 | 现在我们要创建我们的两个 |
| 00:04:24,720 | 主合约，new file DecentralizedStableCoin |
| 00:04:30,260 | 用大写 C .sol，这 |
| 00:04:34,980 | 只是实际的代币，所以 |
| 00:04:37,919 | 我实际上要复制粘贴我的 |
| 00:04:40,320 | 函数布局，因为我喜欢它们 |
| 00:04:42,600 | 我喜欢有这个 |
| 00:04:44,400 | 在顶部当然是 SPDX |
| 00:04:47,520 | license |
| 00:04:48,620 | identifier 和我的团队，如果你想你 |
| 00:04:51,360 | 可以直接从 GitHub 复制这个 |
| 00:04:53,760 | 与这门课程相关的 repo，SRC |
| 00:04:57,000 | 在这里复制这个布局，我喜欢 |
| 00:04:59,520 | 有它作为参考，然后你已经 |
| 00:05:01,439 | 知道 pragma solidity |
| 00:05:04,820 | 0.8.18，我们将做 contract |
| 00:05:07,679 | Decentralized |
| 00:05:10,199 | Stable |
| 00:05:11,760 | Coin，就像这样，现在这将 |
| 00:05:15,000 | 是我们在这里编写的代码与 |
| 00:05:16,380 | 我们之前做的所有其他项目之间的主要区别之一 |
| 00:05:18,480 | 我们将对我们的 |
| 00:05:19,740 | 代码文档非常详细，原因 |
| 00:05:22,919 | 是当涉及到将要审查 |
| 00:05:25,439 | 这个代码的安全专业人员时 |
| 00:05:27,900 | 如果我们有大量 |
| 00:05:29,340 | 文本解释我们的代码在做什么，我们会让他们的 |
| 00:05:31,320 | 生活轻松得多 |
| 00:05:34,320 | 此外，如果你使用 AI，AI |
| 00:05:36,620 | 在阅读和 |
| 00:05:39,480 | 理解语言方面非常出色，所以越多 |
| 00:05:41,400 | 语言来解释我们的代码应该做什么 |
| 00:05:43,439 |  |
| 00:05:45,300 | 我们的代码就越好 |
| 00:05:47,760 | 可以通过一些 AI |
| 00:05:50,579 | 模型发送，以确保它没有 |
| 00:05:52,860 | 问题，所以我们要 |
| 00:05:55,800 | 在这里添加一些 natspec，从一开始就 |
| 00:05:58,199 | @title Decentralized |
| 00:06:01,980 | Stablecoin 全部一个词，@author |
| 00:06:06,240 | Patrick Collins 或者写你的名字 |
| 00:06:08,340 | 是的，这是开源的 MIT license，你 |
| 00:06:10,800 | 可以随心所欲地使用它 |
| 00:06:12,179 | 留下说 collateral |
| 00:06:14,600 | 外生的 ETH 和 BTC，minting 或 |
| 00:06:19,020 | 稳定性机制将是 |
| 00:06:22,820 | 算法化的，意味着它是去中心化的 |
| 00:06:25,559 | 相对稳定性将被锚定到 |
| 00:06:29,039 | USD，然后我将在这里说 |
| 00:06:32,100 | 这是将由 DSC engine 治理的 |
| 00:06:35,459 | 合约 |
| 00:06:41,220 | 这个合约 |
| 00:06:42,780 | 只是，我将在这里切换自动换行 |
| 00:06:45,900 | 我们稳定币系统的 ERC20 实现 |
| 00:06:51,059 |  |
| 00:06:52,199 | 所以这就是 |
| 00:06:54,840 | 这个去中心化稳定币将 |
| 00:06:57,000 | 纯粹是一个带有 minting |
| 00:07:00,300 | 和 burning 等功能的 ERC20，对吧，它不会 |
| 00:07:02,220 | 它不会有任何 |
| 00:07:04,320 | 逻辑，逻辑将在 |
| 00:07:06,120 | 一个单独的合约中 |
| 00:07:07,559 | 所以让我们开始制作这个 |
| 00:07:09,959 | 所以首先 Constructor |
| 00:07:12,000 | boom，我们将使用 Open |
| 00:07:14,100 | Zeppelin 来启动这个，所以 |
| 00:07:16,919 | 在顶部 import，实际上 |
| 00:07:19,559 | 在我们这样做之前，forge install |
| 00:07:22,100 | OpenZeppelin/openzeppelin-dash |
| 00:07:26,459 | contracts --no-dash commit，并且 |
| 00:07:30,360 | 我们继续，我们已经安装了 |
| 00:07:31,679 | 那个，现在我们要打开我们的 |
| 00:07:33,740 | foundry.toml，我们要添加一些 |
| 00:07:36,120 | remappings，所以 remappings 等于 |
| 00:07:39,600 | @openzeppelin |
| 00:07:42,240 | /contracts=lib/open |
| 00:07:45,780 | zeppelin |
| 00:07:47,220 | /contracts/contracts |
| 00:07:50,640 | 看起来不错 |
| 00:07:52,079 | 在这个顶部现在 |
| 00:07:54,480 | import 命名导入 ERC20，我们将 |
| 00:07:58,740 | 导入这个 ERC20Burnable 合约，我会 |
| 00:08:01,260 | 稍后解释这个，然后还有 |
| 00:08:02,760 | ERC20 from @openzeppelin/ |
| 00:08:06,059 | contracts/token/erc20 |
| 00:08:09,000 | /extensions |
| 00:08:11,280 | /ERC20Burnable.sol |
| 00:08:14,760 | 我拼对了吗 |
| 00:08:16,620 | 看起来是对的，所以我做了什么，哦 |
| 00:08:18,840 | 哎呀，看起来我拼错了 contracts |
| 00:08:20,459 | 让我们拼对它，好的酷 |
| 00:08:22,140 | 看起来不错，现在我们要 |
| 00:08:24,000 | 说我们的去中心化稳定 |
| 00:08:26,520 | 币，让我甚至缩小一点 |
| 00:08:28,079 | 是的，这将是一个大的，所以 |
| 00:08:30,240 | 我们要稍微缩小一点 |
| 00:08:31,199 | 希望你们都能看到这是 |
| 00:08:33,740 | ERC20Burnable，好的，我们将 |
| 00:08:37,320 | 使用这个合约的原因，如果我们 |
| 00:08:38,760 | command 点击它或只是查找它 |
| 00:08:40,559 | 是它有这个 burn 函数，我们想要 |
| 00:08:43,740 | 这个 burn 函数，因为这将 |
| 00:08:45,240 | 帮助我们维持锚定价格，我们将 |
| 00:08:47,400 | burn 很多这些 |
| 00:08:48,840 | 代币，你稍后会理解的 |
| 00:08:50,579 | 现在与 ERC20 相同，所以 ERC20 |
| 00:08:53,820 | burnable 合约是一个 ERC20，这就是 |
| 00:08:58,020 | 为什么我们也可以从它导入 ERC20 合约 |
| 00:09:00,240 | 并且 ERC20 burnable |
| 00:09:02,520 | Constructor 是一个 ERC20，这意味着我们 |
| 00:09:05,159 | 也必须使用 ERC20 Constructor |
| 00:09:08,640 | 它接受一个名称，我们将 |
| 00:09:10,800 | 称我们的为 Decentralized |
| 00:09:13,340 | Stablecoin 和 DSC，就像这样，这就是 |
| 00:09:17,640 | 全部了，这将是我们整个 |
| 00:09:18,780 | Constructor，我们不会触碰它 |
| 00:09:20,159 | 这就是我们要做的全部，让我放大 |
| 00:09:22,199 | 一点，我将不断 |
| 00:09:23,459 | 放大和缩小，希望这不会 |
