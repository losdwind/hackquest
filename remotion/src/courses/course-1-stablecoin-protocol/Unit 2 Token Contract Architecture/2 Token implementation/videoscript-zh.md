# 2 Token实现

> 实现DecentralizedStableCoin合约，继承ERC20Burnable和Ownable，mint/burn访问控制。

| 时间戳 | 内容 |
| :--- | :--- |
| 00:00:00,000 | 不会太疯狂，现在我们希望这个 |
| 00:00:03,059 | coin 100%由我们的engine管理 |
| 00:00:07,080 | 我们的engine将有所有这些 |
| 00:00:09,780 | 关于使用什么collateral的东西，如何 |
| 00:00:13,620 | 使用它，peg到什么等等，这个 |
| 00:00:16,260 | 纯粹只是token，所以 |
| 00:00:18,539 | 既然我们希望这个token 100% |
| 00:00:21,179 | 被我们的logic控制，我们要 |
| 00:00:23,399 | 让这个也是ownable，这意味着 |
| 00:00:26,220 | 我们将有only owner modifiers |
| 00:00:28,139 | 其中owner将是那个 |
| 00:00:29,760 | immutable logic，我们要创建 |
| 00:00:31,740 | 所以open Zeppelin也有一个包 |
| 00:00:33,539 | 所以我们要做import ownable |
| 00:00:35,820 | from at open Zeppelin slash contracts |
| 00:00:39,000 | slash access |
| 00:00:41,240 | ownable.sol，我要复制这个 |
| 00:00:44,039 | 所以我们的contract将是erc20 |
| 00:00:45,899 | burnable，它将是ownable |
| 00:00:48,480 | 将有两个主要 |
| 00:00:50,820 | 函数，我们希望我们的engine拥有 |
| 00:00:54,480 | 这些函数将是function |
| 00:00:56,700 | burn |
| 00:00:57,840 | 它接受一个uint256 |
| 00:01:00,780 | underscore amount |
| 00:01:02,519 | public，我们要override |
| 00:01:05,159 | burnable的burn函数，这将 |
| 00:01:07,139 | 是only owner，这样只有engine |
| 00:01:09,919 | 只有我们给它的logic才能mint |
| 00:01:12,780 | 和burn，我们要说uint256 |
| 00:01:15,200 | balance等于 |
| 00:01:17,700 | balance of message.sender |
| 00:01:21,240 | 我们要确保 |
| 00:01:23,460 | 当有人试图burn |
| 00:01:25,260 | 一些token时，他们至少有那么多 |
| 00:01:26,760 | token，所以我们首先要说 |
| 00:01:29,159 | 如果amount小于或等于 |
| 00:01:32,519 | 零，那么他们不能burn对吧，我们不 |
| 00:01:35,460 | 希望人们试图burn零，那很 |
| 00:01:37,080 | 傻，所以我们要revert一个 |
| 00:01:39,840 | error，我要把我们所有的errors |
| 00:01:41,939 | 放在这里的顶部，error |
| 00:01:44,159 | decentralized stablecoin underscore |
| 00:01:46,320 | underscore must be more than zero像 |
| 00:01:51,659 | 这样，所以我们要revert这个 |
| 00:01:53,519 | error，然后我们还要说 |
| 00:01:55,320 | if |
| 00:01:56,340 | 用户的balance小于 |
| 00:01:58,800 | 他们试图burn的amount |
| 00:02:00,720 | 那么我们要revert |
| 00:02:02,519 | 用另一个custom error，我只是要 |
| 00:02:04,439 | 复制粘贴 |
| 00:02:05,760 | 我只是要说burn amount |
| 00:02:08,720 | exceeds balance |
| 00:02:11,399 | 完成，粘贴进去像这样，然后 |
| 00:02:14,580 | 最后我们要做这个叫 |
| 00:02:15,419 | super dot burn的东西，我们还没有 |
| 00:02:17,280 | 讨论过，所以这个super关键字 |
| 00:02:19,919 | 基本上是说嘿 |
| 00:02:22,200 | 使用来自父 |
| 00:02:25,320 | 类的burn函数，在这个例子中是erc20 |
| 00:02:27,840 | burnable，所以所有这些代码将 |
| 00:02:29,879 | 运行，它会到这一行，它会 |
| 00:02:32,519 | 说嘿去Super类 |
| 00:02:33,899 | 并使用那里的burn函数，所以我们的 |
| 00:02:36,720 | 代码会说哦好的，嗯erc20 |
| 00:02:38,460 | burnable那是super类或 |
| 00:02:40,260 | 父类，啊只是使用 |
| 00:02:42,240 | 这里的burn函数，它调用 |
| 00:02:44,340 | 这里erc20.sol中的burn函数 |
| 00:02:47,039 | 它做所有这里的这些东西，所以 |
| 00:02:49,620 | 这就是super关键字做的，only |
| 00:02:51,899 | owner，only engine将添加这个 |
| 00:02:53,639 | 现在我们要做这个function mint |
| 00:02:56,280 | 这将是一个address to和一个 |
| 00:02:59,580 | uint256 underscore amount |
| 00:03:03,000 | 这将是public |
| 00:03:05,039 | 抱歉这实际上将是 |
| 00:03:06,120 | external |
| 00:03:07,200 | 也是only owner，这个可能也可以 |
| 00:03:09,840 | 是external |
| 00:03:11,519 | 但那会在audit中出来 |
| 00:03:14,100 | external only owner |
| 00:03:16,080 | 这实际上将return |
| 00:03:18,539 | Boolean，当你做mint时你想 |
| 00:03:20,879 | 在这里有一个Boolean的return，当你 |
| 00:03:23,039 | 做mint，我们将return true，如果 |
| 00:03:24,720 | 它真的works |
| 00:03:25,980 | 但我们要说if |
| 00:03:27,659 | to等于address零，我们要 |
| 00:03:30,720 | 对inputs做一些清理 |
| 00:03:34,439 | 在这里，那么我们要revert，revert |
| 00:03:37,439 | 用一个新error，error |
| 00:03:40,139 | decentralized stablecoin not zero address |
| 00:03:43,439 | 我们不会让人们 |
| 00:03:44,939 | 意外地mint到zero address |
| 00:03:46,800 | 因为那发生得相当多，我们 |
| 00:03:49,559 | 要说如果amount小于 |
| 00:03:52,559 | 或等于零，那么我们也要 |
| 00:03:54,480 | revert这个more than zero |
| 00:03:58,860 | error在这里，完成，然后最后我们要 |
| 00:04:02,039 | return true，哦然后 |
| 00:04:04,080 | 显然我们应该运行mint，underscore |
| 00:04:07,439 | to，underscore amount，所以我们不是 |
| 00:04:10,320 | override这里的任何函数对吧 |
| 00:04:12,539 | 我们只是调用这里的mint函数 |
| 00:04:14,820 | 我们必须做super因为我们 |
| 00:04:17,100 | override burn函数，我们 |
| 00:04:18,960 | 说嘿做所有这些东西然后做 |
| 00:04:20,939 | 常规的burn，这里没有mint |
| 00:04:22,980 | 函数，有一个underscore mint |
| 00:04:24,600 | 函数我们要调用 |
| 00:04:25,919 | 你猜怎么着 |
| 00:04:27,600 | 就这样，这个contract完成了，我们不 |
| 00:04:30,539 | 在这里做更多了，Forge build，很好， |
| 00:04:34,439 | 然后我们可能想为这个写一些 |
| 00:04:35,520 | 测试，写一个deploy脚本，但 |
| 00:04:37,260 | 我们会在一会儿做所有那些 |
| 00:04:38,340 |  |
| 00:04:42,539 | 现在我们要做的是 |
| 00:04:45,059 | 构建engine，这辆车的engine |
| 00:04:46,919 | 这个contract的主要组件 |
| 00:04:49,379 | 你想休息一下，为自己感到骄傲 |
| 00:04:51,600 | 在这里，去做吧 |
| 00:04:53,639 | 如果你甚至想暂停视频 |
| 00:04:55,200 | 开始写你自己的一些测试 |
| 00:04:56,520 | 写你自己的deploy Scripts |
| 00:04:58,139 | 去做吧，但让我们开始 |
| 00:05:01,740 | 构建这个engine |
| 00:05:04,020 | 我们要构建这个，有点 |
| 00:05:05,340 | 不同于我们之前的一些 |
| 00:05:06,419 | 项目，我们甚至可能测试 |
| 00:05:08,639 | 一些这个，在过程中确保 |
| 00:05:10,500 | 我们把事情做对，所以我要 |
| 00:05:12,840 | 创建一个新文件 |
| 00:05:18,200 | decentralized stablecoin engine，让我们 |
| 00:05:21,240 | 为这辆车构建这个engine，好的 |
| 00:05:24,899 | 让我们回到 |
| 00:05:26,760 | 让我拿，我只是要复制粘贴 |
| 00:05:29,100 | 这个开始部分，让我们来到 |
| 00:05:31,679 | engine，粘贴进去，我们有spdx，contracts的layout |
| 00:05:35,220 | pragma solidity，contract |
| 00:05:38,899 | DSC engine |
| 00:05:41,760 | 这个 |
| 00:05:42,780 | 让我们给这个很多natspec |
| 00:05:46,080 | 好的，title DSC engine，我不想 |
| 00:05:48,960 | 那个at author，啊或 |
| 00:05:53,340 | Patrick Collins，这个系统被设计为 |
| 00:05:57,539 | 尽可能minimal |
| 00:06:01,200 | 并让tokens维持一个一 |
| 00:06:06,059 | 美元 |
| 00:06:07,020 | 保持一个one token等于一 |
| 00:06:11,639 | 美元Peg，让我们toggle word wrap |
| 00:06:14,159 | 这个stable coin有这些属性 |
| 00:06:22,740 | algorithmic stable，它类似于DAI |
| 00:06:26,760 | 如果DAI |
| 00:06:28,260 | 没有治理，没有费用，并且只是 |
| 00:06:32,399 | 被wrapped eth和wrapped |
| 00:06:36,600 | Bitcoin支持，at notice这个contract是 |
| 00:06:40,320 | DSC系统的core，它处理所有 |
| 00:06:46,620 | minting和redeeming DSC的logic |
| 00:06:51,500 | 以及存入 |
| 00:06:55,020 | 和提取collateral，notice这个 |
| 00:06:59,939 | contract非常松散地基于DAI，在 |
| 00:07:06,480 | maker DAO DSS DAI系统上，你可能 |
| 00:07:11,939 | 在问Patrick，这里有很多文本 |
| 00:07:13,980 | 是的，我们希望很多文本，当 |
| 00:07:17,399 | 人们读我们的代码时，我们的代码应该 |
| 00:07:19,679 | 可读，记住 |
| 00:07:21,840 | 你的代码将被写一次 |
| 00:07:24,240 | 读成千上万次，我 |
| 00:07:28,260 | 读过Ave和maker代码很多 |
| 00:07:32,039 | 次，很多其他人也是 |
| 00:07:34,500 | 你想要你的代码非常 |
| 00:07:36,659 | verbose，这样其他人可以来 |
| 00:07:38,580 | 理解发生了什么，所以让我们 |
| 00:07:42,240 | 开始 |
| 00:07:43,439 | 所以让我们想想我们的项目应该有什么主要 |
| 00:07:45,419 | 函数 |
| 00:07:48,059 | 我们应该做的主要事情之一 |
| 00:07:49,800 | 在我们开始甚至开始编码之前 |
| 00:07:51,720 | 任何东西，很多时候很多人 |
| 00:07:54,000 | 会采取这一步并实际 |
| 00:07:55,800 | 为他们的代码创建一个interface |
| 00:07:57,659 | 他们会创建一个 |
| 00:07:59,700 | interface并说嘿，这是 |
| 00:08:01,020 | 我希望这个做的所有函数， |
| 00:08:03,000 | 然后他们会说嘿，我们的contract是 |
| 00:08:04,679 | 那个interface，这样他们不会忘记 |
| 00:08:06,419 | 任何那些函数，对我们来说，我只是 |
| 00:08:09,000 | 要把它们写在这里 |
| 00:08:10,139 | 所以我想要一个function是 |
| 00:08:12,300 | function |
| 00:08:13,220 | deposit collateral and mint DSC，我想 |
| 00:08:18,720 | 人们能够存入他们的DAI |
| 00:08:20,520 | 或他们的Bitcoin并mint我们的DSC token |
| 00:08:23,760 | 我想让人们redeem |
| 00:08:26,220 | 他们的collateral for DSC |
| 00:08:29,100 | 对吧，当人们完成 |
| 00:08:31,559 | 用stable coin做他们想做的事 |
| 00:08:33,119 | 他们可以把stable coin，DSC decentralized stable coin |
| 00:08:37,439 | 换回他们 |
| 00:08:39,419 | 最初使用的任何collateral |
| 00:08:40,800 | 我想让人们能够function |
| 00:08:43,439 | burn他们的DSC，这样做的原因是 |
| 00:08:46,860 | 如果他们担心他们有太多 |
| 00:08:49,320 | stablecoin而没有足够的 |
| 00:08:50,520 | collateral，他们想要一个快速的 |
| 00:08:51,840 | 方式有更多collateral而不是DSC |
| 00:08:54,300 | 他们可以快速burn东西，这是 |
| 00:08:57,240 | 系统的另一部分 |
| 00:08:58,980 | 我们甚至应该在这里放一个点，我们的 |
| 00:09:01,560 | DSC应该 |
| 00:09:04,020 | 或DSC系统应该总是over |
| 00:09:08,879 | collateralized |
| 00:09:10,980 | 在任何时候，所有collateral的价值 |
| 00:09:14,280 | 不应该小于或等于 |
| 00:09:18,240 | 所有DSC的价值或 |
| 00:09:22,980 | 所有DSC的美元支持价值，我们 |
| 00:09:26,820 | 应该总是有更多collateral而不是 |
| 00:09:29,340 | 系统中的DSC，在所有时候，我们 |
| 00:09:31,500 | 需要用这种方式编码，所以burn DSC |
| 00:09:34,679 | 是一个函数，会更有意义 |
| 00:09:37,080 | 一会儿，我们应该有一个 |
| 00:09:39,060 | function |
| 00:09:40,080 | 叫liquidate，这将是 |
| 00:09:42,659 | 一个非常重要的函数，原因 |
| 00:09:45,179 | 我们总是要有更多 |
| 00:09:47,280 | collateral，如果他们的collateral价值 |
| 00:09:49,200 | 掉得太多，假设 |
| 00:09:51,540 | 假设我放入100美元的eth， |
| 00:09:55,020 | 我minted五十美元的DSC，我 |
| 00:09:59,040 | 有更多collateral而不是DSC，那是 |
| 00:10:01,080 | 好的，如果eth价格暴跌到 |
| 00:10:05,760 | 四十美元，四十eth，现在我们是under |
| 00:10:09,540 | collateralized对吧，现在我们有更少的 |
| 00:10:11,520 | eth而不是DSC，保持，这个 |
| 00:10:15,840 | 用户应该被清算 |
| 00:10:17,939 | 他们不应该被允许持有一个position |
| 00:10:19,560 |  |
| 00:10:20,520 | 在我们的系统中anymore |
| 00:10:22,500 | 所以理想情况下，我们设置一些threshold，太 |
| 00:10:25,200 | 低，也许是20% |
| 00:10:28,379 | 如果你持有60美元的eth，五十 |
| 00:10:31,560 | 美元的DSC，你应该 |
| 00:10:33,360 | 被踢出系统，因为你 |
| 00:10:34,800 | 太接近being under |
| 00:10:36,240 | collateralized了，这个liquidate函数 |
| 00:10:38,820 | 将是其他 |
| 00:10:40,919 | 用户可以调用来移除人们的 |
| 00:10:43,020 | positions来保存protocol的函数，我们会 |
| 00:10:45,480 | 稍后更多谈论那个 |
| 00:10:46,980 | 很快，我们要想要function |
| 00:10:48,600 | Health Factor |
| 00:10:50,580 | 这应该是一个external view函数 |
| 00:10:52,500 | 或抱歉，get health Factor，这 |
| 00:10:55,980 | 将允许看到人们有多健康 |
| 00:10:57,899 | 所以让我们回到这个例子 |
| 00:11:01,560 | 所以如果，如果eth的价格跌到四十 |
| 00:11:04,500 | 美元，我们现在十美元under |
| 00:11:06,840 | collateralized对吧，那不好 |
| 00:11:09,419 | 那真的很糟糕，我们永远不想这个 |
| 00:11:11,639 | 发生 |
| 00:11:12,360 | 所以我们能做的是，我们可以设置一个 |
| 00:11:14,820 | threshold为，比如这个例子 |
| 00:11:19,740 | 五十%或一百五十 |
| 00:11:22,860 | %，所以如果你在系统中有五十美元 |
| 00:11:25,379 |  |
| 00:11:26,399 | 你需要在所有时候至少有75 eth |
| 00:11:29,159 |  |
| 00:11:29,939 | 这样有一点 |
| 00:11:31,379 | buffer，这样我们永远不会是under |
| 00:11:33,179 | collateralized，如果价格在这里tank |
| 00:11:34,980 | 如果你到七十四美元，现在 |
| 00:11:37,800 | 我们能做的是，我们可以liquidate， |
| 00:11:40,320 | 我们可以说嘿，如果有人liquidate，如果 |
| 00:11:44,280 | 有人偿还你的borrow，你的 |
| 00:11:47,820 | minted DSC，他们可以有你所有的 |
| 00:11:52,379 | collateral或一个discount |
| 00:11:55,139 | 所以也许我们说嘿，有人偿还 |
| 00:11:57,720 | 这50 DSC，你可以有这74 |
| 00:12:02,820 | 美元的eth，有人会 |
| 00:12:04,980 | 非常有动力做这个，因为 |
| 00:12:06,240 | 他们会赚二十，二十四 |
| 00:12:07,740 | 美元 |
| 00:12:08,580 | 所以我们会设置一些threshold，也许150 |
| 00:12:11,460 | %，我们会说嘿，任何 |
| 00:12:13,919 | liquidate你position的人，如果你 |
| 00:12:16,139 | 低于threshold，他们可以作为 |
| 00:12:18,840 | 奖励有你的一些额外collateral， |
| 00:12:21,360 | 这会激励人们总是 |
| 00:12:22,919 | 有额外的collateral，否则他们会 |
| 00:12:24,899 | 损失比他们更多的钱 |
| 00:12:26,460 | 借的，那没有意义，所以 |
| 00:12:28,919 | 再来一次，让我们做那个例子，所以如果我 |
| 00:12:31,740 | mint，所以如果我放下100美元 |
| 00:12:34,679 | 的ether作为collateral，我mint |
| 00:12:37,320 | 五十美元的DSC，现在我要 |
| 00:12:40,020 | 去做我想用DSC做的任何事 |
| 00:12:42,060 | 我的eth价格tank到 |
| 00:12:45,960 | 75美元 |
| 00:12:47,820 | 或者更好，让我们说七十四 |
| 00:12:49,439 | 美元，一些其他用户会看到 |
| 00:12:51,600 | 哦我的天，under collateralize |
| 00:12:54,600 | 我们会让人们liquidate |
| 00:12:56,399 | 他们的positions，如果他们变成under |
| 00:12:57,960 | collateralized，基于threshold |
| 00:13:00,119 | 一些其他用户会看到那个 |
| 00:13:01,560 | 他们会说好的，我会 |
| 00:13:04,080 | 偿还50个DSC，我会偿还 |
| 00:13:08,100 | 五十美元的DSC，所以现在这个人 |
| 00:13:09,480 | 有零债务，作为回报，得到你所有的 |
| 00:13:13,439 | collateral |
| 00:13:14,580 | 所以现在这个人有零美元 |
| 00:13:16,320 | 的eth，这个用户得到了74 |
| 00:13:19,740 | 美元，他们所要做的就是支付 |
| 00:13:22,679 | 五十美元的DSC来得到七十四 |
| 00:13:25,679 | 美元的eth，所以这个人现在up |
| 00:13:28,320 | 刚赚了二十五美元或二十 |
| 00:13:30,540 | 四美元 |
| 00:13:31,500 | 为什么liquidating你，他们被激励 |
| 00:13:34,860 | 赚钱 |
| 00:13:35,879 | 这是你的惩罚，让 |
| 00:13:37,560 | 你的collateral变得太低 |
| 00:13:39,960 | 所以希望这有意义，如果这个 |
| 00:13:42,000 | liquidations系统对你来说没有 |
| 00:13:43,800 | 意义，你知道去哪里，来 |
| 00:13:46,139 | 到这个课程的GitHub repos |
| 00:13:47,820 | 开始加入讨论，好 |
| 00:13:50,340 | 的，所以希望这有意义，如果 |
| 00:13:51,840 | 没有，使用讨论tab |
| 00:13:53,340 | 当然，现在这些是这种 |
| 00:13:55,159 | 组合函数，我们可能 |
| 00:13:57,240 | 想要一个函数只叫 |
| 00:13:58,679 | deposit，这个deposit collateral，external |
| 00:14:02,879 | 我可能想要function |
| 00:14:05,280 | redeem |
| 00:14:07,020 | collateral，external，然后我们可能 |
| 00:14:10,020 | 想要 |
| 00:14:11,340 | 连同burn DSC，我们可能 |
| 00:14:13,260 | 想要function mint DSC |
| 00:14:16,020 | external，这些看起来像，这些可能 |
| 00:14:18,480 | 会是大部分 |
| 00:14:20,159 | protocol做的，很多 |
| 00:14:21,960 | 人甚至做的是，有时他们甚至 |
| 00:14:23,460 | 现在写测试，描述 |
| 00:14:26,100 | 每一个实际应该对系统做什么 |
| 00:14:27,960 | 对吧，我们不会 |
| 00:14:29,760 | 那样做，但我们可能实际上写一些 |
| 00:14:31,260 | 测试，当我们在这里继续时 |
| 00:14:33,780 | 我喜欢写我的deploy脚本 |
| 00:14:36,419 | 比较早，你会看到我在这里做那个 |
| 00:14:38,100 | 这样我可以使用我的 |
| 00:14:40,980 | deploy脚本写测试，所以让我们开始吧 |
| 00:14:47,220 | 最好的地方在哪里开始 |
| 00:14:49,020 | 解决这个，嗯，对我来说最简单的 |
| 00:14:51,480 | 地方开始实际上是 |
| 00:14:52,619 | depositing对吧，因为那是 |
| 00:14:54,600 | 人们实际上要做的第一件事 |
| 00:14:55,919 | 用这个protocol，是 |
| 00:14:57,060 | 实际deposit collateral，所以我 |
| 00:14:59,460 | 要从那里开始，所以对这个deposit |
| 00:15:01,980 | collateral函数 |
| 00:15:03,480 | 他们在这里要想做什么 |
| 00:15:04,800 | 嗯 |
| 00:15:05,700 | 我们要需要让他们选择 |
| 00:15:07,320 | collateral，他们想deposit，所以我们 |
| 00:15:08,820 | 说address token collateral address |
| 00:15:12,659 | 然后还有uint256 amount |
| 00:15:15,659 | collateral，我们要做一个 |
| 00:15:17,639 | toggle word wrap，好的很好 |
| 00:15:19,919 | 所以deposit collateral，token |
| 00:15:21,899 | collateral address，然后 |
| 00:15:23,460 | 他们要做的amounts，所以 |
| 00:15:25,139 | 我们已经可以看到，会有 |
| 00:15:26,760 | 一堆东西我们 |
| 00:15:27,960 | 要在这里做，所以 |
| 00:15:30,179 | 让我们甚至做一点natspec |
| 00:15:32,460 | 在这里有点specific，我们说 |
| 00:15:34,619 | at param，我们只是解释什么 |
| 00:15:36,240 | params是，这就是 |
| 00:15:39,119 | GitHub copilot真的有帮助的地方 |
| 00:15:41,159 | 因为很多时候，它真的擅长 |
| 00:15:44,159 | docs，所以我们要说at param，at param |
| 00:15:48,780 | 所以这两个都不错，token |
| 00:15:50,280 | collateral address，要 |
| 00:15:51,899 | deposit的token amount作为collateral，不是collateral |
| 00:15:53,939 | 要deposit的collateral的amount |
| 00:15:55,260 | 对吧，真的简单，所以我们要想要 |
| 00:15:57,780 | 这里的几个东西，我们要 |
| 00:15:59,340 | 想清理一下这个，所以 |
| 00:16:00,960 | amount collateral，我们绝对 |
| 00:16:02,399 | 想要这个是more than zero |
| 00:16:04,560 | 所以我们可能想要 |
| 00:16:05,639 | 一个叫more than zero的modifier，我们可以 |
| 00:16:07,679 | 在这些函数中使用 |
| 00:16:09,359 | 有时人们可能意外发送 |
| 00:16:11,280 | 一个零transaction，我们想 |
| 00:16:12,659 | 自动revert那些，所以 |
| 00:16:15,179 | 我们滚动到这里的顶部，我们看到我们的 |
| 00:16:18,000 | modifiers在我们的functions之前 |
| 00:16:20,939 | 所以我们要创建我们的modifiers |
| 00:16:22,919 | 在这里，我们甚至要添加像一个 |
| 00:16:24,780 | 小小section，用一堆 |
| 00:16:27,419 | 这些在这里，modifiers |
| 00:16:32,100 | 像这样 |
| 00:16:33,359 | 很好，我们说modifier |
| 00:16:36,200 | more than zero，这个modifier将 |
| 00:16:39,659 | 接受一个uint256 amount， |
| 00:16:43,800 | 我们只是说if amount |
| 00:16:46,379 | 等于零，那么我们要 |
| 00:16:48,899 | revert一个新error |
| 00:16:51,960 | errors去哪里，让我们到顶部 |
| 00:16:54,560 | errors去 |
| 00:16:57,119 | 就在Imports下面，实际上 |
| 00:16:59,760 | 不太对，它们要去 |
| 00:17:01,260 | 就在contract下面 |
| 00:17:03,419 | 所以我们要做，我们要复制 |
| 00:17:05,760 | 这整个section |
| 00:17:08,639 | 我们要说errors |
| 00:17:10,439 | 我们要来这里 |
| 00:17:11,760 | 所以我们要说error |
| 00:17:13,500 | DSC engine underscore underscore |
| 00:17:16,500 | 我们想叫什么 |
| 00:17:18,000 | 我只是needs more than zero，needs more |
| 00:17:21,000 | than zero像这样，然后我们要 |
| 00:17:24,179 | revert needs more than zero，当然 |
| 00:17:26,939 | 在这里添加小underscore |
| 00:17:28,439 | 很好，所以现在我们有一个more than zero |
| 00:17:30,480 | modifier，所以我们可以让这个 |
| 00:17:32,760 | external more than zero，我们会传 |
| 00:17:35,399 | amount collateral，完成，好的很好 |
| 00:17:38,220 | 我们在这里做一些标准化 |
| 00:17:39,600 | 我们还应该做什么 |
| 00:17:41,520 | 你知道，让我们甚至 |
| 00:17:43,500 | 复制这个 |
| 00:17:44,939 | 我们在这里粘贴，我们说 |
| 00:17:47,539 | functions，我们要有一个 |
| 00:17:50,579 | Constructor |
| 00:17:51,659 | 所以我现在只是把这个放在这里 |
| 00:17:52,980 | constructor，拼写Constructor对 |
| 00:17:56,039 | 然后 |
| 00:17:57,840 | 我们要有一个section，在 |
| 00:17:59,960 | functions后，像一个subsection，我们要 |
| 00:18:02,280 | 叫它 |
| 00:18:03,360 | external |
| 00:18:04,440 | functions |
| 00:18:05,940 | 这个external functions很好，因为我们 |
| 00:18:09,058 | 想去 |
| 00:18:10,320 | receive和fallback，我们不会 |
| 00:18:12,119 | 有那些，但然后是external和public |
| 00:18:14,400 | 所以external function首先 |
| 00:18:16,920 | 无论如何，好的 |
| 00:18:18,240 | 好的，more than zero，有那个，我们 |
| 00:18:20,820 | 可能不想让人们使用任何 |
| 00:18:23,340 | collateral对吧，我们可能只想 |
| 00:18:25,018 | 他们使用 |
| 00:18:26,159 | 我们允许的某些collateral，所以 |
| 00:18:28,440 | 我们要创建一个新modifier |
| 00:18:29,759 | 叫is allowed token，所以我们要 |
| 00:18:34,499 | 做modifier is allowed token，这 |
| 00:18:39,058 | 将接受一个 |
| 00:18:40,619 | address token |
| 00:18:42,360 | 基本上我们要说 |
| 00:18:44,219 | 如果token不被允许 |
| 00:18:46,380 | token不被允许那么revert |
| 00:18:48,900 | 对吧，然而此刻我们没有 |
| 00:18:51,179 | 像一个token allow list，所以让我们 |
| 00:18:53,039 | 创建那个，这可能会是 |
| 00:18:55,639 | 一个state mapping，所以让我们滚动到 |
| 00:18:58,619 | 顶部或state variables去哪里，所以errors |
| 00:19:02,340 | type Declaration state variables，好的 |
| 00:19:04,920 | errors很好，让我们把它放在这里，State |
| 00:19:08,460 | variables |
| 00:19:10,200 | 好的，让我们做我们的 |
| 00:19:12,420 | 让我们创建 |
| 00:19:13,980 | 一个mapping的allowed list，所以我们做 |
| 00:19:16,320 | mapping |
| 00:19:18,058 | address到Bool，你知道private |
| 00:19:22,018 | s underscore token to allowed |
| 00:19:25,920 | 我们可以这样做，然而我已经知道 |
| 00:19:28,200 |  |
| 00:19:29,280 | 我们要需要price feeds，所以 |
| 00:19:31,799 | 相反我要做的是，我不 |
| 00:19:34,380 | 要做address到Bool，我要 |
| 00:19:36,420 | 做address到address，这将 |
| 00:19:39,539 | 是我们的price feed mapping，所以 |
| 00:19:41,100 | 它将是s underscore price |
| 00:19:42,480 | feeds |
| 00:19:43,499 | 通常我做语法 |
| 00:19:46,558 | token to price feed对吧，但对这个 |
| 00:19:50,820 | 我们只是要叫这个price |
| 00:19:51,840 | feeds，我们要使用较新的 |
| 00:19:53,518 | solidity命名mappings来让这个 |
| 00:19:56,700 | 更清楚一点，所以我要说 |
| 00:19:57,719 | address token |
| 00:19:59,700 | maps到address price feed |
| 00:20:03,420 | 所以现在这是s price feed，任何人 |
| 00:20:05,280 | 可以查找并说啊好的，所以这是 |
| 00:20:06,840 | token到price feed，很好，所以我们要 |
| 00:20:09,539 | 有这个price feeds列表， |
| 00:20:12,120 | 我们应该在哪里设置这个，嗯 |
| 00:20:13,999 | 我们可能要 |
| 00:20:16,679 | 在Constructor中设置这个对吧 |
| 00:20:18,660 | 当我们部署这个contract时，那就是当 |
| 00:20:20,340 | 我们要说好的，这些将 |
| 00:20:21,420 | 是允许的tokens，这些price |
| 00:20:23,160 | feeds，这样它会 |
| 00:20:24,600 | 永远那样对吧，我们永远不会 |
| 00:20:26,400 | 能改变这个，所以我们要做的是 |
| 00:20:28,740 | 在我们的Constructor中，现在 |
| 00:20:30,600 | 我们会接受 |
| 00:20:32,340 | 允许的tokens和它们的price |
| 00:20:34,799 | feeds对吧，因为为了这个 |
| 00:20:37,620 | 系统work，我们要像 |
| 00:20:39,978 | data.chain.link，为了这整个 |
| 00:20:42,600 | 系统work，如果我们想知道 |
| 00:20:45,660 | 人们存入的ethereum的价值 |
| 00:20:47,940 | 在这里值多少，我们需要有 |
| 00:20:49,860 | pricing对吧，我们知道的唯一方式 |
| 00:20:51,840 | 我们是否over collateralized，如果我们 |
| 00:20:54,058 | 知道我们的eth和 |
| 00:20:55,860 | Bitcoin的价值，所以我们要使用这两个 |
| 00:20:57,840 | price feeds来 |
| 00:20:59,400 | 维持那个，因为这些price |
| 00:21:01,259 | feeds将在不同 |
| 00:21:02,219 | chains上的不同addresses，你 |
| 00:21:04,200 | 已经知道我们必须参数化 |
| 00:21:06,058 | 它，所以我们要做一个address array |
| 00:21:09,240 | memory |
| 00:21:11,219 | token addresses |
| 00:21:12,780 | 我的address array |
| 00:21:14,880 | memory |
| 00:21:16,320 | price |
| 00:21:17,460 | feed addresses |
| 00:21:19,679 | 作为input参数 |
| 00:21:21,360 | 我们要说 |
| 00:21:22,799 | token address 0 maps到price feed零 |
| 00:21:25,018 | token orders 1 maps到price feed 1 |
| 00:21:27,058 | 等等 |
| 00:21:27,780 | 当我们在这里时，我已经知道 |
| 00:21:30,420 | 我们的DSC engine将需要 |
| 00:21:32,999 | 知道我们的decentralized stablecoin |
| 00:21:35,340 | 为什么，因为我们的DSC engine要 |
| 00:21:37,620 | 需要知道调用burn和mint，所以在 |
| 00:21:40,499 | 这里的Constructor中，这也是 |
| 00:21:42,719 | 我们要传address的地方 |
| 00:21:44,299 | DSC address，decentralized stablecoin |
| 00:21:46,978 | address |
| 00:21:47,759 | 所以在这里 |
| 00:21:49,380 | 让我们对这个做一些sanity checks |
| 00:21:51,840 | 我们说如果token addresses |
| 00:21:55,499 | length不等于price feed |
| 00:21:58,259 | addresses |
| 00:21:59,460 | price feed addresses |
| 00:22:01,978 | feed addresses length，我们有问题 |
| 00:22:05,280 | 对吧，因为如果有更多tokens或 |
| 00:22:06,900 | 更多price feeds，那意味着我们搞砸了 |
| 00:22:08,880 | 什么，所以我们要 |
| 00:22:10,440 | revert一个新error，去到我们的 |
| 00:22:13,558 | errors这里，我们说error |
| 00:22:15,600 | DSC engine underscore underscore token |
| 00:22:19,039 | addresses |
| 00:22:21,719 | 和price feed addresses必须是same |
| 00:22:26,940 | length，这是一个巨大的error，我知道，但我 |
| 00:22:29,999 | 喜欢verbose，像我之前 |
| 00:22:31,320 | 告诉你的 |
| 00:22:32,100 | 所以如果那些不匹配，我们要 |
| 00:22:34,320 | revert |
| 00:22:35,700 | 然后我们要循环遍历 |
| 00:22:36,840 | token addresses并更新我们的mapping |
| 00:22:39,960 | 我们刚才在上面创建的 |
| 00:22:42,240 | 说好的，token address被mapped |
| 00:22:45,058 | 到price feed address |
| 00:22:46,558 | 现在为了我们获取pricing |
| 00:22:48,179 | 我们要使用 |
| 00:22:49,740 | USD price feeds，所有，每个 |
| 00:22:53,940 | price feed我们要 |
| 00:22:55,139 | 使用的将是USD支持的price |
| 00:22:56,880 | feed，所以比如 |
| 00:22:59,100 | 它将是eth USD，BTC USD，mkr USD |
| 00:23:05,820 | 等等 |
| 00:23:06,478 | 好的，所以我们要循环遍历 |
| 00:23:08,160 | 我们要说for uint256 i等于 |
| 00:23:11,639 | 零，i小于token addresses |
| 00:23:15,960 | dot length，i加加 |
| 00:23:18,660 | 所以我们要循环遍历这个 |
| 00:23:19,679 | token addresses数组，我们要 |
| 00:23:21,719 | 说s underscore price feeds |
| 00:23:25,320 | of token addresses |
| 00:23:27,780 | i将等于price feed |
| 00:23:31,100 | addresses of i，所以我们要设置 |
| 00:23:34,499 | 这个price feed，所以无论token |
| 00:23:37,018 | 所以i的token将等于 |
| 00:23:39,240 | i的price feed，这就是我们 |
| 00:23:40,860 | 要设置哪些tokens |
| 00:23:43,860 | 在我们平台上被允许，如果它们有一个 |
| 00:23:45,900 | price feed它们被允许，如果它们没有 |
| 00:23:48,058 | 它们不被允许，然后我知道 |
| 00:23:50,400 | 我们要用我们的 |
| 00:23:51,478 | DSC做很多东西，所以这就是，这 |
| 00:23:54,600 | 绝对将是一个immutable |
| 00:23:55,799 | 变量，所以我们可以向上滚动，做一个 |
| 00:23:58,320 | immutable变量，我们说 |
| 00:24:00,240 | 所以我们说decentralized stablecoin |
| 00:24:03,740 | private i underscore DSC，因为我们 |
| 00:24:07,080 | 要让这个immutable |
| 00:24:08,700 | 既然我们使用decentralized |
| 00:24:10,018 | stable coin，我们要import |
| 00:24:11,280 | 这个 |
| 00:24:13,380 | 所以让我们去顶部这里 |
| 00:24:15,539 | 做import decentralized stablecoin from dot |
| 00:24:19,320 | slash |
| 00:24:20,058 | decentralizedstablecoin.sol，所以现在 |
| 00:24:22,920 | decentralized stablecoin private idsc，我们可以 |
| 00:24:26,160 | 现在做，哦抱歉，这将是 |
| 00:24:27,840 | private immutable |
| 00:24:31,799 | 在Constructor中稍微往下一点 |
| 00:24:33,120 | 我们只是要说idsc等于 |
| 00:24:35,280 | decentralized stablecoin DSC address |
| 00:24:37,978 | 像那样，再次使用GitHub copilot，如果 |
| 00:24:40,860 | 你没有GitHub copilot，那 |
| 00:24:42,840 | 没关系，有很多其他免费AI |
| 00:24:44,400 | 你也可以使用 |
| 00:24:46,499 | 很好，所以我们设置了我们的Constructor，我们 |
| 00:24:49,920 | 回到deposit collateral |
| 00:24:52,259 | 我们做这个的整个原因是，我们 |
| 00:24:53,880 | 说好的，我们应该只允许某些 |
| 00:24:55,679 | 种类的collateral在我们的平台上，所以 |
| 00:24:58,320 | 现在我们可以创建一个新modifier叫 |
| 00:25:00,780 | is allowed token，我们可以只是说 |
| 00:25:03,840 | if |
| 00:25:05,160 | s underscore price feeds |
| 00:25:07,380 | of token等于address零，那么 |
| 00:25:11,700 | 我们可以revert |
| 00:25:13,440 | 用一个新的，哦，那看起来像一个好的 |
| 00:25:15,780 | DSC engine token not allowed，我只是 |
| 00:25:17,820 | 要复制那个，去顶部， |
| 00:25:20,400 | 谢谢copilot，只是自动为我填充了 |
| 00:25:22,558 | 好的很好，然后当然我们 |
| 00:25:24,840 | 需要在这里做这个，很好，所以is |
| 00:25:27,719 | token allowed，more than zero，is allowed |
| 00:25:31,440 | 抱歉，is allowed token |
| 00:25:33,478 | token |
| 00:25:35,219 | collateral |
| 00:25:37,200 | address像这样 |
| 00:25:39,299 | 好的很好，然后此外，我 |
| 00:25:41,999 | 要添加一个 |
| 00:25:43,999 | non-reentrant modifier在这里 |
| 00:25:46,740 | 我们要从open |
| 00:25:48,660 | Zeppelin拿这个，每当我们与 |
| 00:25:50,700 | 外部contracts工作时，可能是一个好 |
| 00:25:53,639 | 主意，考虑让你的函数 |
| 00:25:55,280 | non-reentrant，reentrancies是 |
| 00:25:57,960 | 所有web 3中最常见的攻击之一 |
| 00:26:00,620 | 老实说，有时我只是撕 |
| 00:26:04,080 | 一个non-reentrant modifier，即使我 |
| 00:26:06,179 | 很确定它不容易受到 |
| 00:26:08,039 | reentrancy攻击 |
| 00:26:09,360 | 我觉得老实说，大多数函数 |
| 00:26:11,580 | 默认应该是non-reentrant，但 |
| 00:26:13,820 | 特别是当与外部 |
| 00:26:16,200 | contracts工作时，可能是个好主意 |
| 00:26:18,240 | 把这个modifier放在这里，现在这可能去 |
| 00:26:20,460 | audit，我们可能说嘿，嗯，我们不 |
| 00:26:22,920 | 需要这个non-reentrant modifier， |
| 00:26:24,600 | 也许我们去掉它，但也许我们 |
| 00:26:26,460 | 不去，权衡是，有这个在这里 |
| 00:26:28,860 | gas稍微密集一点，但 |
| 00:26:31,080 | 它也更安全，所以我只是要 |
| 00:26:33,719 | 把它放在这里，即使我 |
| 00:26:35,880 | 很确定我不需要它，我们要 |
| 00:26:37,679 | 从open Zeppelin获取这个，有一个 |
| 00:26:40,380 | non-reentrancy，一个non-reentrant |
| 00:26:42,920 | modifier，从它们的reentrancy guard，所以 |
| 00:26:45,660 | 我们要import |
| 00:26:46,860 | 实际上我的GitHub copilot自动 |
| 00:26:50,039 | 有了reentrancy Guard from open |
| 00:26:51,660 | Zeppelin contracts |
| 00:26:54,058 | security reentrancy guard Soul，是的 |
| 00:26:56,340 | 那实际上完全正确 |
| 00:26:58,440 | 然后我们能做的是向下滚动 |
| 00:27:01,080 | 我们看到我们的DSC engine is reentrancy |
| 00:27:04,018 | guard，通过这样做，我们现在有 |
| 00:27:06,120 | 访问这个 |
| 00:27:07,759 | non-reentrant modifier的权限，现在这个 |
| 00:27:11,039 | 函数是non-reentrant的，这就是 |
| 00:27:13,620 | 我们想要的，好的很好，现在我们可以最终 |
| 00:27:15,900 | 开始做一些collateral的东西，所以 |
| 00:27:17,940 | 我们要deposit这个 |
| 00:27:19,139 | collateral，我们需要做的第一件事 |
| 00:27:20,940 | 是一个方法来跟踪多少 |
| 00:27:22,920 | collateral有人实际 |
| 00:27:24,179 | deposited了，所以那看起来像什么，嗯 |
| 00:27:27,058 | 那对我来说可能看起来像一个mapping |
| 00:27:28,620 | 所以让我们去顶部，我们要创建一个 |
| 00:27:31,440 | mapping |
| 00:27:33,058 | of |
| 00:27:34,320 | address user到 |
| 00:27:38,039 | mapping of一个address |
| 00:27:40,679 | token到uint256 amount |
| 00:27:44,700 | private s underscore，很好很好，卷到 |
| 00:27:49,080 | deposited |
| 00:27:52,259 | 所以这是一个mapping到一个mapping，疯狂 |
| 00:27:54,600 | 对吧，所以我们要map用户的 |
| 00:27:56,940 | balances到一个tokens的mapping，它 |
| 00:27:59,999 | 会被mapped到amount |
| 00:28:02,460 | 他们拥有的每个token的，好的，所以 |
| 00:28:04,620 | 让我们向下滚动 |
| 00:28:06,240 | 到我们的deposit collateral函数，所以 |
| 00:28:08,880 | 现在我们有一个collateral deposited |
| 00:28:11,160 | mapping，所以我们可以做s collateral |
| 00:28:13,380 | deposited of message.sender of这个 |
| 00:28:17,219 | token collateral address，现在我们 |
| 00:28:19,080 | 知道它是一个允许的collateral address |
| 00:28:21,840 | 它将是加等于 |
| 00:28:24,299 | amount collateral对吧，我 |
| 00:28:27,900 | 实际上遇到一个问题，当 |
| 00:28:29,759 | 我做Forge format，格式化代码 |
| 00:28:33,179 | 看起来像这样，但现在当我 |
| 00:28:35,580 | 保存时，它以不同的 |
| 00:28:37,740 | 方式重新格式化，所以我要做的是，看起来 |
| 00:28:40,080 | 它使用了一个不同的formatter |
| 00:28:41,639 | 我不喜欢，所以我要去 |
| 00:28:42,900 | extensions，solidity hard hat，点击 |
| 00:28:46,080 | 这里的settings，extension settings， |
| 00:28:48,900 | 我们要把这个从prettier |
| 00:28:50,219 | 改为forge，因为我想使用forge |
| 00:28:52,139 | format设置，现在如果我点击save，好的 |
| 00:28:54,960 | 很好，它以我想要的方式保存并格式化 |
| 00:28:57,539 | 好的很好，所以你可以在这里看到 |
| 00:28:59,639 | 我们正在更新State，什么 |
| 00:29:01,499 | 我们应该做，当我们更新State，我们 |
| 00:29:03,539 | 应该emit |
| 00:29:04,920 | 一个event，所以我们要emit |
| 00:29:06,660 | collateral |
| 00:29:08,420 | deposited，我们要让它是 |
| 00:29:10,978 | message.sender，谁正在depositing |
| 00:29:13,018 | token collateral address和 |
| 00:29:16,679 | amount collateral也 |
| 00:29:19,139 | 这意味着我们有我们的第一个event |
| 00:29:21,440 | 好的 |
| 00:29:23,100 | 所以让我们上到这里，向外zoom |
| 00:29:26,400 | 一直滚动到layout |
| 00:29:27,719 | events去哪里，events在 |
| 00:29:30,120 | state variables后，好的，所以我要 |
| 00:29:31,679 | 复制这个 |
| 00:29:32,880 | 去state variables后 |
| 00:29:34,440 | modifiers前，所以我们要 |
| 00:29:36,179 | 说events，你要去这里 |
| 00:29:39,478 | 我们要说event |
| 00:29:42,539 | github copilot自动填充了 |
| 00:29:44,940 | 它给我，太棒了，address indexed |
| 00:29:46,740 | user，address indexed token，uint256 amount，我们 |
| 00:29:50,580 | 真的不需要index那个，也许我们 |
| 00:29:52,499 | 需要，为什么不，让我们只是index它，好的 |
| 00:29:55,200 | 很好，只是要知道一个keyboard |
| 00:29:57,660 | 快捷键我经常使用是control |
| 00:29:59,280 | back或control minus，它允许你 |
| 00:30:02,039 | 回到你在你代码中的最后一个地方 |
| 00:30:04,320 | 如果你做Ctrl shift minus |
| 00:30:06,900 | 它会向前，我一直使用这个 |
| 00:30:08,639 | 所以比如如果我在下面 |
| 00:30:11,039 | 我的代码这里，我点击control back，我会 |
| 00:30:14,280 | 只是回到我的 |
| 00:30:16,080 | cruiser所在的最后一个地方，我一直使用这个 |
| 00:30:18,539 | 我不确定keyboard快捷键 |
| 00:30:20,400 | 在 |
| 00:30:21,420 | windows或linux上是什么，但在Mac上它是 |
| 00:30:23,820 | control back和control shift back， |
| 00:30:25,799 | 我一直使用它，无论如何，所以我们在 |
| 00:30:28,920 |  |
| 00:30:29,700 | deposit collateral，我们有这个emit |
| 00:30:31,920 | 这里，我们最终有event，好的 |
| 00:30:34,139 | 很好，所以我们正在更新collateral |
| 00:30:37,200 | 内部记录保存，我们正在emitting |
| 00:30:40,139 | event，现在当然我们应该实际 |
| 00:30:42,058 | 获取tokens对吧，你可以在这里看到 |
| 00:30:44,160 | 我们遵循CEI对吧，所以我们做 |
| 00:30:48,179 | 一个小 |
| 00:30:49,018 | notice遵循CEI，checks effects |
| 00:30:53,039 | interactions |
| 00:30:54,840 | 所以所有checks都在我们的 |
| 00:30:56,639 | modifiers这里发生，这些是所有checks |
| 00:30:58,440 | 我们的effects就在这里，然后 |
| 00:31:01,380 | 最后我们的外部interactions，所以 |
| 00:31:04,139 | 这就是我们要做那个的地方 |
| 00:31:04,920 | transfer from |
| 00:31:06,660 | 我们要把我们的collateral |
| 00:31:08,880 | 包装为一个erc20 |
| 00:31:10,920 | 所以我们要需要调用transfer |
| 00:31:12,719 | from在它上面，所以我要import IERC20 from at open Zeppelin |
| 00:31:18,240 | contracts |
| 00:31:19,679 | slash |
| 00:31:21,299 | token slash erc20 |
| 00:31:24,259 | ierc20.sol，Ctrl minus回到 |
| 00:31:28,080 | 下面这里，不是很好吗，我们可以 |
| 00:31:30,360 | 最终做IERC20 of token collateral |
| 00:31:33,840 | address |
| 00:31:34,978 | dot transfer from message dot sender |
| 00:31:39,240 | 到address this |
| 00:31:42,240 | amount collateral |
| 00:31:45,058 | 像这样，我们说，所以这个函数 |
| 00:31:48,360 | 实际上返回一个Boolean，bool success |
| 00:31:51,179 | 我们想确保这个 |
| 00:31:53,219 | 实际上是true |
| 00:31:54,478 | 所以我们想说if not success |
| 00:31:57,719 | 我们只会revert DSC engine |
| 00:32:01,679 | 我只是要说transfer failed |
| 00:32:04,440 | 像这样，这是什么，一个error，你打赌 |
| 00:32:08,400 | 它是，所以我们把这个放在顶部，error |
| 00:32:10,920 | DSC engine transfer failed |
| 00:32:13,259 | 我要点击Ctrl minus去 |
| 00:32:15,120 | 回到我正在工作的代码 |
| 00:32:16,558 |  |
| 00:32:17,820 | 很好，所以这个函数对我来说看起来很好 |
| 00:32:20,820 | 我能够在这里deposit collateral |
| 00:32:23,039 | 并更新我们的mappings，现在可能 |
| 00:32:26,039 | 是我们开始写的好时机 |
| 00:32:28,139 | 一些测试对吧，我们可以 |
| 00:32:30,478 | 做类似我们之前做的 |
| 00:32:31,740 | 我们只是扔在一起 |
| 00:32:33,840 | 一个真正快速的setup在我们的unit |
| 00:32:36,240 | test中，然后让我们的integration test |
| 00:32:37,978 | 是我们的deploy脚本实际使用的 |
| 00:32:41,400 | 嗯，让我们先写几个更多函数 |
| 00:32:43,259 | 然后我们可以做 |
| 00:32:44,880 | 所有那些工作 |
| 00:32:49,380 | 所以我们有一个方法deposit |
| 00:32:51,299 | collateral，好的很棒，我们接下来应该 |
| 00:32:54,478 | 做什么，嗯，我们应该做的下一件事 |
| 00:32:55,799 | 是有一个方法mint我们的DSC |
| 00:32:59,219 | token对吧，一旦他们deposit |
| 00:33:00,600 | collateral，他们应该能够Mint |
| 00:33:01,679 | DSC token，然后 |
| 00:33:04,320 | 这两个的组合将是这个函数 |
| 00:33:06,120 | deposit collateral and mint DSC，所以让我们 |
| 00:33:08,940 | 实际创建这个mint |
| 00:33:10,320 | DSC函数，因为现在他们有 |
| 00:33:12,600 | 一些collateral，我们应该能够 |
| 00:33:13,920 | Mint一些DSC，现在这实际上 |
| 00:33:15,719 | 会是一个令人惊讶地复杂 |
| 00:33:17,639 | 方法对吧，因为为了Mint |
| 00:33:19,679 | DSC，我们需要检查collateral是否 |
