# 5 审计准备

| 时间戳 | 内容 |
| :--- | :--- |
| 04:30:38 | 或者我们可以说这是一个已知的bug，如果 |
| 04:30:41 | 价格波动或爆炸得太 |
| 04:30:43 | 快或太慢，这个协议 |
| 04:30:45 | 就变得毫无价值，这有点不是 |
| 04:30:47 | 一个很好的解决方案，对吧，所以这些是 |
| 04:30:49 | 我们绝对想要记住的事情 |
| 04:30:50 | 这些是我们可以 |
| 04:30:52 | 通过invariant测试发现的事情，这就是 |
| 04:30:55 | 为什么它们如此重要，所以现在在 |
| 04:30:57 | 我们的Handler中，我实际上只会 |
| 04:30:59 | 把这个注释掉，因为它确实 |
| 04:31:01 | 破坏了我们的测试套件，但我会 |
| 04:31:03 | 在这里加一个小注释，这会破坏 |
| 04:31:05 | 我们的invariant测试套件，这 |
| 04:31:08 | 100%会是在 |
| 04:31:11 | 智能合约审计中出现的东西，说嘿，如果 |
| 04:31:13 | 资产价格暴跌得太快 |
| 04:31:16 | 系统就会崩溃，因为它破坏了 |
| 04:31:18 | invariant，好的，很好，现在 |
| 04:31:21 | 还有几件事我想 |
| 04:31:22 | 教，只有几件，然后我们就完成了 |
| 04:31:24 | 这一部分 |
| 04:31:25 | 我们将教一些正确的 |
| 04:31:28 | Oracle使用，然后第二，我们需要写 |
| 04:31:32 | 更多测试 |
| 04:31:33 | 我们不会做，我会 |
| 04:31:35 | 把这个留给你，但我们有一大堆 |
| 04:31:37 | 其他合约在这里，比如 |
| 04:31:38 | 去中心化稳定币 |
| 04:31:40 | 然后第三，一些智能合约审计 |
| 04:31:43 | 准备工作 |
| 04:31:45 | 一些智能合约审计准备 |
| 04:31:48 | 所以让我们从一些正确的Oracle |
| 04:31:50 | 使用开始 |
| 04:31:55 | 所以在我们的DSC engine中，我们当然 |
| 04:31:57 | 在使用oracle，对吧，我们在使用Chainlink |
| 04:32:00 | 价格预言机，现在这是一种 |
| 04:32:02 | 我们在协议中的假设 |
| 04:32:04 | 现在价格预言机只会 |
| 04:32:07 | 工作，但价格预言机是一个系统 |
| 04:32:09 | 就像其他任何东西一样，我们应该 |
| 04:32:11 | 在我们的代码中添加一些检查 |
| 04:32:14 | 只是为了确保如果这个坏了或者 |
| 04:32:18 | 如果这里的某些东西坏了，我们的系统 |
| 04:32:20 | 不会坏 |
| 04:32:21 | 所以我们要做的是 |
| 04:32:23 | 实际使用我们多年前制作的Library方法 |
| 04:32:25 | 来对这个价格预言机写一些检查 |
| 04:32:28 | 所以我要创建一个 |
| 04:32:32 | libraries文件夹，我们要创建 |
| 04:32:34 | 一个新合约叫做 |
| 04:32:37 | OracleLib.sol |
| 04:32:39 | 我们想做的是检查 |
| 04:32:42 | 确保这些价格不是陈旧的 |
| 04:32:44 | 如果我们点击这些价格中的任何一个 |
| 04:32:46 | 比如ETH/USD，让我们向上滚动显示 |
| 04:32:50 | 更多详情 |
| 04:32:52 | 显示更多详情，你可以看到 |
| 04:32:54 | 它们有这个心跳，一个新的 |
| 04:32:57 | 价格应该至少每3600秒出现一次 |
| 04:32:59 | 我相信这是对的 |
| 04:33:01 | 是的，在这个Polygon测试网上，我们想 |
| 04:33:04 | 写一些检查来确保这个 |
| 04:33:06 | 实际上每3600秒更新一次 |
| 04:33:08 | 如果不是，我们可能应该暂停 |
| 04:33:10 | 我们合约的功能，所以 |
| 04:33:13 | 我们要创建一个SPDX |
| 04:33:16 | license |
| 04:33:17 | identifier MIT，pragma solidity像 |
| 04:33:21 | 这样 |
| 04:33:22 | 我们要做一个library |
| 04:33:24 | OracleLib，让我们加一点 |
| 04:33:26 | natspec来解释这是什么 |
| 04:33:28 | 要做的，说@title，哎呀 |
| 04:33:32 | title OracleLib，@author Patrick |
| 04:33:37 | Collins |
| 04:33:39 | @notice |
| 04:33:41 | 这个library用于检查Chainlink |
| 04:33:46 | Oracle是否有陈旧 |
| 04:33:47 | 数据 |
| 04:33:50 | 如果价格是陈旧的 |
| 04:33:53 | 函数 |
| 04:33:54 | 将回滚并使DSC engine |
| 04:34:00 | 无法使用，这是有意设计的，所以我们 |
| 04:34:04 | 要说，嘿，如果Chainlink价格 |
| 04:34:06 | 预言机是陈旧的，就停止，不要让 |
| 04:34:08 | 任何事情发生，因为如果价格 |
| 04:34:10 | 错了，如果价格坏了，我们整个 |
| 04:34:12 | 协议就有点废了，对吧，所以我们 |
| 04:34:14 | 想冻结一切，所以我们 |
| 04:34:17 | 想让DSC engine冻结，如果价格 |
| 04:34:22 | 变得陈旧 |
| 04:34:25 | 所以如果Chainlink |
| 04:34:27 | 网络爆炸了，你有很多 |
| 04:34:32 | 钱锁在协议中 |
| 04:34:35 | 太糟糕了，这是一个 |
| 04:34:37 | 已知问题，对吧，如果Chainlink |
| 04:34:38 | 网络崩溃了，所有价格 |
| 04:34:40 | 都变陈旧了 |
| 04:34:41 | 是的，你有点完蛋了，对吧 |
| 04:34:43 | 也许这是我们想要 |
| 04:34:45 | 考虑的事情，但现在我只会 |
| 04:34:47 | 说这是一个已知问题，我们 |
| 04:34:48 | 继续，这就是 |
| 04:34:50 | 你会看到我开始越来越 |
| 04:34:52 | 特别关注东西的地方，这是 |
| 04:34:55 | 随着我们越来越高级 |
| 04:34:57 | 细节开始变得越来越 |
| 04:34:59 | 重要的地方，对吧，所有那些小小的 |
| 04:35:01 | 我有点略过的事情 |
| 04:35:02 | 开始变得越来越 |
| 04:35:04 | 重要，因为这越来越接近 |
| 04:35:06 | 一个真实的生产产品 |
| 04:35:09 | 应该去审计，对吧，所以让我们 |
| 04:35:12 | 创建一个陈旧价格检查函数 |
| 04:35:15 | 创建一个function stale price |
| 04:35:18 | check，我们会让这个stale price |
| 04:35:21 | check在aggregatorV3 |
| 04:35:24 | Interface.sol上，所以我实际上要 |
| 04:35:26 | 复制这个 |
| 04:35:27 | 粘贴到这里，切换自动换行 |
| 04:35:30 | 所以作为输入参数，它会 |
| 04:35:32 | 接受AggregatorV3Interface |
| 04:35:34 | priceFeed，这将是一个public view |
| 04:35:37 | 返回一个uint80、int256 |
| 04:35:43 | uint256、uint256和一个 |
| 04:35:47 | uint80，相同的 |
| 04:35:50 | latestRoundData的返回值 |
| 04:35:54 | 函数在AggregatorV3Interface |
| 04:35:55 | 函数中，像这样，好的，在这里 |
| 04:36:01 | 我们要做的是调用 |
| 04:36:02 | priceFeed.latest |
| 04:36:03 | RoundData，我甚至要作弊 |
| 04:36:07 | 一点，我们要control点击 |
| 04:36:11 | 进入这个，我们要复制这行 |
| 04:36:13 | 粘贴到这里，等于 |
| 04:36:16 | 嘣，这样我就不用打那么多字了 |
| 04:36:19 | 很好，我们有了所有这些 |
| 04:36:21 | 我们要在这里说 |
| 04:36:24 | 我们可能不会用到所有这些 |
| 04:36:26 | 我们要有一些陈旧检查 |
| 04:36:27 | 对吧，所以这些价格预言机中的每一个 |
| 04:36:28 | 都有自己的心跳，所以我们可能 |
| 04:36:30 | 应该问它们的心跳是什么 |
| 04:36:32 | 但我只会硬编码 |
| 04:36:33 | 这一个，我要说 |
| 04:36:36 | uint256 private constant |
| 04:36:37 | TIMEOUT等于3 hours |
| 04:36:39 | 这是Solidity中的一个常量 |
| 04:36:43 | 代表 |
| 04:36:46 | 3乘60分钟乘60秒 |
| 04:36:48 | 等于 |
| 04:36:50 | 呃这么多秒，所以看起来这个 |
| 04:36:54 | 心跳实际上比 |
| 04:34:55 | Chainlink应该允许的长得多，所以 |
| 04:34:58 | 3600秒就是一个 |
| 04:35:00 | 小时，对吧，我们要给它三 |
| 04:35:02 | 小时，所以我们要在这里说 |
| 04:35:06 | 首先我们要做一个uint256 secondsSince等于 |
| 04:35:07 | block.timestamp |
| 04:35:09 | 然后我们会有 |
| 04:35:10 | 抱歉，减去 |
| 04:35:14 | updatedAt |
| 04:35:16 | 然后我们会说，所以这会得到 |
| 04:35:18 | 当前区块时间戳减去这个 |
| 04:35:20 | updatedAt，所以这基本上应该得到 |
| 04:35:22 | 自这个价格预言机 |
| 04:35:25 | 更新以来的秒数，然后我们说如果secondsSince |
| 04:35:27 | 大于我们的timeout，那么 |
| 04:35:30 | 我们要用一个新error回滚 |
| 04:35:32 | error |
| 04:35:35 | OracleLib，我只会下划线 |
| 04:35:39 | 它，StalePrice像这样，用 |
| 04:35:42 | StalePrice回滚，然后我们只会返回 |
| 04:35:44 | 所有这些东西，所以return roundId |
| 04:35:47 | answer startedAt updatedAt answeredInRound |
| 04:35:50 | 我会把这个名字改成 |
| 04:35:52 | staleCheck |
| 04:35:53 | LatestRoundData，现在 |
| 04:35:57 | 我们可以做什么，因为这是一个library |
| 04:36:01 | 在 |
| 04:36:02 | 我们的priceFeed上，我们可以使用这个staleCheck |
| 04:36:03 | LatestRoundData来自动 |
| 04:36:05 | 检查 |
| 04:36:07 | 价格是否陈旧，所以现在 |
| 04:36:09 | 在我们的DSC engine中，任何时候我们调用latest |
| 04:36:11 | RoundData |
| 04:36:13 | 我们只需用staleCheck |
| 04:36:15 | LatestRoundData替换它，只要在顶部 |
| 04:36:17 | 我们去 |
| 04:36:18 | 在我们的errors之后，我们要放我们的 |
| 04:36:22 | types |
| 04:36:26 | 在errors之后我们要放 |
| 04:36:28 | types |
| 04:36:30 | 所以这是我们会做using |
| 04:36:32 | OracleLib for AggregatorV3Interface的地方 |
| 04:36:34 | 我们需要import OracleLib，让我们import |
| 04:36:36 | OracleLib from |
| 04:36:37 | 抱歉，./libraries |
| 04:36:39 | /OracleLib.sol |
| 04:36:40 | 像这样，现在是的，任何地方我们使用 |
| 04:36:43 | latestRoundData，我们现在可以使用stale |
| 04:36:49 | CheckLatestRoundData，我们有 |
| 04:36:52 | 这个陈旧检查内置其中，很好，现在 |
| 04:36:55 | 我们做了大量重构，让我们运行 |
| 04:36:57 | forge test来运行整个测试 |
| 04:36:59 | 套件，包括invariant测试套件 |
| 04:37:02 | 好的，东西看起来不错 |
| 04:37:05 | 你可以看到它甚至花了很多 |
| 04:37:07 | 额外时间来运行最后这一部分 |
| 04:37:09 | 所以很好，我们有一个小检查 |
| 04:37:12 | 我们不会写更多测试 |
| 04:37:14 | 这是你应该100%做的事情 |
| 04:37:16 | 我们在这里打开终端，我们运行 |
| 04:37:28 | forge coverage |
| 04:37:30 | 你觉得我们会得到什么 |
| 04:37:32 | 我们得到这个，你可以看到有一大堆 |
| 04:37:34 | 我们需要测试的合约 |
| 04:37:38 | 这个OracleLib可能需要 |
| 04:37:39 | 它自己的测试套件，即使看起来 |
| 04:37:42 | 很多已经被测试了 |
| 04:37:45 | 我们可能应该自己测试这个 |
| 04:37:46 | 我们需要为此写测试 |
| 04:37:55 | 我们可能想多测试我们的 |
| 04:37:57 | DSC，肯定的 |
| 04:37:58 | 所以我们绝对应该写更多 |
| 04:38:01 | 测试，我会把这个留给你 |
| 04:38:03 | 这个小手指 |
| 04:38:05 | 然后最后是一些智能合约 |
| 04:38:06 | 审计准备，所以我们稍微谈了一下 |
| 04:38:08 | 什么是智能合约审计 |
| 04:38:11 | 我们还没有涵盖很多 |
| 04:38:14 | 安全方面的东西，我们会在 |
| 04:38:15 | 课程后面做，但一个可靠的 |
| 04:38:18 | 地方你可以看看是这个审计 |
| 04:38:27 | 准备清单，来自nascent XYZ |
| 04:38:29 | GitHub仓库，它有很多不同的 |
| 04:38:31 | 你在运行测试时应该记住的事情 |
| 04:38:33 | 对于那些 |
| 04:38:36 | 真正认真想要 |
| 04:38:37 | 实际启动协议并真正 |
| 04:38:39 | 拥有你需要的安全思维的人 |
| 04:38:40 | 一定要 |
| 04:38:41 | 到达课程中的最后一个 |
| 04:38:44 | 部分 |
| 04:38:47 | 关于安全介绍，因为这是 |
| 04:38:52 | 我们会给你很多 |
| 04:38:54 | 更底层的安全内容的地方，至少 |
| 04:38:56 | 从智能合约开发者的 |
| 04:38:58 | 角度，我们会给你所有 |
| 04:39:00 | 你需要意识到的基础知识 |
| 04:39:02 | 以保持安全，所以我们不会 |
| 04:39:04 | 在这个中谈论太多 |
| 04:39:07 | 但这是如果我们 |
| 04:39:08 | 真的要启动这个，我们需要 |
| 04:39:11 | 记住的事情 |
| 04:39:13 | 所以我会在这里放一个soon表情 |
| 04:39:15 | 很快就来 |
| 04:39:16 | 好的，说了这么多 |
| 04:39:19 | 我们在这里做了绝对大量的工作 |
| 04:39:21 | 这是1000%一个你 |
| 04:39:23 | 应该推送到你GitHub仓库的项目 |
| 04:39:25 | 这是1000%一个 |
| 04:39:28 | 如果你走到这一步，你应该 |
| 04:39:33 | 为自己感到非常自豪的项目 |
| 04:39:36 | 这是最难、最复杂、最 |
| 04:39:40 | 高级的项目 |
| 04:39:43 | 在这个课程中，老实说可能 |
| 04:39:45 | 是你会在 |
| 04:39:48 | 几乎所有web3中工作的最高级项目 |
| 04:39:50 | 这里有太多东西了，我们学习了DeFi |
| 04:39:53 | 我们学习了高级的最先进的 |
| 04:39:55 | 现代fuzzing技术，我们学习了一点点 |
| 04:39:58 | 关于安全的东西，我们以更安全的方式使用 |
| 04:40:00 | Oracle，我们写了这个 |
| 04:40:02 | 疯狂的惊人测试套件，我们为此写了部署 |
| 04:40:04 | 脚本，我们与几个不同的library |
| 04:40:07 | 交互 |
| 04:40:10 | 我们学习了这个fail on revert |
| 04:40:14 | 运行深度和invariant，我们唯一没做的是 |
| 04:40:16 | 写一个适当的readme |
| 04:40:18 | 你100%应该写一个适当的 |
| 04:40:22 | readme，如果你想，你可以查看 |
| 04:40:24 | Foundry DeFi稳定币readme来看看 |
| 04:40:27 | 它实际如何工作，当然即使对 |
| 04:40:29 | 我来说，这也是一个漫长困难的项目 |
| 04:40:32 | 要构建，因为有太多 |
| 04:40:34 | 要考虑的东西，就像我说的，这是一个 |
| 04:40:36 | 我计划 |
| 04:40:38 | 进行审计的项目，所以你会在 |
| 04:40:41 | 这个仓库中看到 |
| 04:40:44 | 这个主分支，这是你 |
| 04:40:47 | 将要工作的，但我 |
| 04:40:49 | 还会创建一个新分支 |
| 04:40:52 | 叫做audited或post audit或 |
| 04:40:54 | 类似的东西，如果你想 |
| 04:40:56 | 关注并观看这个GitHub仓库 |
| 04:40:58 | 你可以看到进展，你可以看到 |
| 04:41:01 | 出来的审计报告，这样你 |
| 04:41:02 | 可以深入熟悉这个 |
| 04:41:05 | 代码库，因为你写了一些 |
| 04:41:07 | 代码 |
| 04:41:09 | 然后也看到它通过 |
| 04:41:13 | 安全旅程的进展，对于 |
| 04:41:16 | 那些想要实际 |
| 04:41:18 | 发布生产代码的人，你绝对 |
| 04:41:21 | 需要至少了解 |
| 04:41:24 | 安全如何工作以及你的代码应该采取的 |
| 04:41:27 | 安全路径，但好的 |
| 04:41:30 | 说了这么多 |
| 04:41:32 | 你知道现在是什么时候了 |
| 04:41:35 | 是时候让你休息一下了 |
| 04:41:37 | 你值得，你应该100%去走一圈 |
| 04:41:39 | 把这个代码库推送到GitHub |
| 04:41:42 | 实际上把它清理一下，我 |
| 04:41:46 | 会在推送剩余部分到这个 |
| 04:41:50 | GitHub仓库之前把它清理一下 |
| 04:41:51 | 所以你应该清理一下 |
| 04:41:53 | 让它成为你的，按你想要的方式 |
| 04:41:55 | 制作它，甚至可能 |
| 04:41:57 | 改进它，对吧，我们通过invariant测试看到 |
| 04:41:59 | 这个协议至少还有 |
| 04:42:01 | 另一个突出的问题 |
| 04:42:03 | 如果资产价格 |
| 04:42:05 | 崩溃得太快，我们的协议 |
| 04:42:07 | 就会破产，所以也许你想出 |
| 04:42:08 | 一个方法来修复它，然后也许 |
| 04:42:11 | 你启动你自己的稳定币，为什么不呢 |
| 04:42:13 | 对吧，无论如何，祝你好运，休息一下 |
| 04:42:16 | 我们只有，我们越来越 |
| 04:42:18 | 接近了，我们只有一二三个 |
| 04:42:20 | 课程了，这些实际上 |
| 04:42:23 | 比我们刚做的更简单 |
| 04:42:27 | 我们将学习升级和 |
| 04:42:31 | 代理，我们将学习 |
| 04:42:33 | 治理 |
| 04:42:36 | 然后我们将做一个 |
| 04:42:37 | 智能合约安全介绍 |
| 04:42:39 | 这些比你到目前为止做的所有事情 |
| 04:42:40 | 都容易得多，所以休息一下 |
| 04:42:41 | 拍拍自己的背 |
| 04:42:42 | 非常兴奋，庆祝这个胜利 |
| 04:42:45 | 这是一个巨大的成就，能走 |
| 04:42:48 | 这么远 |
| 04:42:50 | 我很快会见到你 |
| 04:42:52 | 还剩三个 |
| 04:42:54 | 作为这里的奖励内容 |
| 04:42:55 | 我绝对喜欢Aave协议和 |
| 04:42:58 | Aave团队的另一个原因是 |
| 04:43:04 | 他们只是在发布 |
| 04:43:07 | 协议和为web3发布惊人的产品 |
| 04:43:09 | 社区的功能和服务 |
| 04:43:11 | 其中之一 |
| 04:43:14 | 协议叫做Lens |
| 04:43:17 | protocol，这是一个去中心化社交 |
| 04:43:19 | 层或去中心化社交平台 |
| 04:43:21 | 用于构建社交媒体，所以为了给我们 |
| 04:43:23 | 一些关于这个的信息，我们有 |
| 04:43:25 | Aave团队Lens protocol的devrel负责人 |
| 04:43:27 | Nader Dabit来稍微谈一谈 |
| 04:43:30 | 更多关于Lens的信息，嗨，我叫Nader |
| 04:43:31 | Dabit，我想给你一个快速 |
| 04:43:33 | Lens protocol的介绍以及为什么它 |
| 04:43:35 | 对你作为智能 |
| 04:43:38 | 合约或Solidity工程师可能很有趣 |
| 04:43:40 | Lens是web3的社交层 |
| 04:43:42 | 它允许 |
| 04:43:44 | 开发者构建社交应用 |
| 04:43:46 | 或将社交功能实现到 |
| 04:43:48 | 他们现有的应用中 |
| 04:43:50 | 今天世界上有49亿人 |
| 04:43:52 | 已经在使用社交应用，所以 |
| 04:43:55 | 这些类型的应用提供了一个用例 |
| 04:43:56 | 人们已经知道、理解和 |
| 04:43:59 | 重视，它们也呈现了各种各样的 |
| 04:44:01 | 价值主张和机会 |
| 04:44:03 | 供开发者利用和 |
| 04:44:05 | 构建，而且web3功能如 |
| 04:44:07 | 原生支付、所有权和 |
| 04:44:09 | 可组合性也提供了很多 |
| 04:44:12 | 基础元素来构建，这些在 |
| 04:44:13 | 传统社交 |
| 04:44:15 | 应用或基础设施中是不可用的 |
| 04:44:17 | Lens允许 |
| 04:44:19 | 开发者通过构建自己的 |
| 04:44:21 | 自定义模块来扩展核心智能 |
| 04:44:23 | 合约，这类似于 |
| 04:44:25 | 如果Twitter、Instagram或其他社交 |
| 04:44:27 | 应用允许开发者发送 |
| 04:44:29 | pull request到他们的后端和 |
| 04:44:31 | API，这为很多 |
| 04:44:33 | 有趣和强大的功能打开了大门 |
| 04:44:36 | 我们看到开发者集成 |
| 04:44:38 | 到他们的应用中，构建新的 |
| 04:44:40 | 不同想法，但也集成到 |
| 04:44:42 | web3的其他部分，如DeFi |
| 04:44:44 | 除此之外，你可以从其他智能合约调用 |
| 04:44:47 | Lens智能合约，所以 |
| 04:44:49 | 如果你想构建一些 |
| 04:44:51 | 可与web3社交 |
| 04:44:53 | 图谱组合的东西，Lens是一个很好的集成地方 |
| 04:44:55 | 如果你想开始在 |
| 04:44:57 | Lens上构建，查看docs.lens.xyz的文档 |
| 04:44:59 | 一定要查看如何在你自己的环境中部署 |
| 04:45:02 | 协议，这样你就可以 |
| 04:45:04 | 查看智能合约代码 |
| 04:45:06 | 玩玩它，也看看如何 |
| 04:45:08 | 构建和创建你自己的自定义 |
| 04:45:10 | 模块，感谢查看 |
| 04:45:12 | |
